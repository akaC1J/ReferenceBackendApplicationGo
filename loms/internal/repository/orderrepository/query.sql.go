// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package orderrepository

import (
	"context"
)

const getOrderById = `-- name: GetOrderById :many
SELECT orders.id,
       orders.state,
       orders.user_id,
       i.sku,
       i.count
FROM orders
JOIN items i on orders.id = i.order_id
WHERE orders.id = $1
`

type GetOrderByIdRow struct {
	ID     int64
	State  OrderStatus
	UserID int64
	Sku    int64
	Count  int64
}

func (q *Queries) GetOrderById(ctx context.Context, orderID int64) ([]*GetOrderByIdRow, error) {
	rows, err := q.db.Query(ctx, getOrderById, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetOrderByIdRow
	for rows.Next() {
		var i GetOrderByIdRow
		if err := rows.Scan(
			&i.ID,
			&i.State,
			&i.UserID,
			&i.Sku,
			&i.Count,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveItems = `-- name: SaveItems :exec
INSERT INTO items (sku, count, order_id)
SELECT unnest($1::bigint[]), unnest($2::bigint[]), $3
`

type SaveItemsParams struct {
	Skus    []int64
	Counts  []int64
	OrderID int64
}

func (q *Queries) SaveItems(ctx context.Context, arg *SaveItemsParams) error {
	_, err := q.db.Exec(ctx, saveItems, arg.Skus, arg.Counts, arg.OrderID)
	return err
}

const saveOrder = `-- name: SaveOrder :one
INSERT INTO orders (state, user_id)
VALUES ($1, $2)
RETURNING id
`

type SaveOrderParams struct {
	State  OrderStatus
	UserID int64
}

func (q *Queries) SaveOrder(ctx context.Context, arg *SaveOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, saveOrder, arg.State, arg.UserID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET state   = $1,
    user_id = $2
WHERE id = $3
RETURNING id
`

type UpdateOrderParams struct {
	State   OrderStatus
	UserID  int64
	OrderID int64
}

func (q *Queries) UpdateOrder(ctx context.Context, arg *UpdateOrderParams) (int64, error) {
	row := q.db.QueryRow(ctx, updateOrder, arg.State, arg.UserID, arg.OrderID)
	var id int64
	err := row.Scan(&id)
	return id, err
}
