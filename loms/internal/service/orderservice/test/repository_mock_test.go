// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package test

//go:generate minimock -i route256/loms/internal/service/orderservice.Repository -o repository_mock_test.go -n RepositoryMock -p test

import (
	"context"
	"route256/loms/internal/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements mm_orderservice.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetById          func(ctx context.Context, orderID int64) (op1 *model.Order, err error)
	funcGetByIdOrigin    string
	inspectFuncGetById   func(ctx context.Context, orderID int64)
	afterGetByIdCounter  uint64
	beforeGetByIdCounter uint64
	GetByIdMock          mRepositoryMockGetById

	funcSaveOrder          func(ctx context.Context, order *model.Order) (op1 *model.Order, err error)
	funcSaveOrderOrigin    string
	inspectFuncSaveOrder   func(ctx context.Context, order *model.Order)
	afterSaveOrderCounter  uint64
	beforeSaveOrderCounter uint64
	SaveOrderMock          mRepositoryMockSaveOrder

	funcUpdateOrder          func(ctx context.Context, order *model.Order) (err error)
	funcUpdateOrderOrigin    string
	inspectFuncUpdateOrder   func(ctx context.Context, order *model.Order)
	afterUpdateOrderCounter  uint64
	beforeUpdateOrderCounter uint64
	UpdateOrderMock          mRepositoryMockUpdateOrder
}

// NewRepositoryMock returns a mock for mm_orderservice.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetByIdMock = mRepositoryMockGetById{mock: m}
	m.GetByIdMock.callArgs = []*RepositoryMockGetByIdParams{}

	m.SaveOrderMock = mRepositoryMockSaveOrder{mock: m}
	m.SaveOrderMock.callArgs = []*RepositoryMockSaveOrderParams{}

	m.UpdateOrderMock = mRepositoryMockUpdateOrder{mock: m}
	m.UpdateOrderMock.callArgs = []*RepositoryMockUpdateOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockGetById struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetByIdExpectation
	expectations       []*RepositoryMockGetByIdExpectation

	callArgs []*RepositoryMockGetByIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetByIdExpectation specifies expectation struct of the Repository.GetById
type RepositoryMockGetByIdExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetByIdParams
	paramPtrs          *RepositoryMockGetByIdParamPtrs
	expectationOrigins RepositoryMockGetByIdExpectationOrigins
	results            *RepositoryMockGetByIdResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetByIdParams contains parameters of the Repository.GetById
type RepositoryMockGetByIdParams struct {
	ctx     context.Context
	orderID int64
}

// RepositoryMockGetByIdParamPtrs contains pointers to parameters of the Repository.GetById
type RepositoryMockGetByIdParamPtrs struct {
	ctx     *context.Context
	orderID *int64
}

// RepositoryMockGetByIdResults contains results of the Repository.GetById
type RepositoryMockGetByIdResults struct {
	op1 *model.Order
	err error
}

// RepositoryMockGetByIdOrigins contains origins of expectations of the Repository.GetById
type RepositoryMockGetByIdExpectationOrigins struct {
	origin        string
	originCtx     string
	originOrderID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetById *mRepositoryMockGetById) Optional() *mRepositoryMockGetById {
	mmGetById.optional = true
	return mmGetById
}

// Expect sets up expected params for Repository.GetById
func (mmGetById *mRepositoryMockGetById) Expect(ctx context.Context, orderID int64) *mRepositoryMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("RepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &RepositoryMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.paramPtrs != nil {
		mmGetById.mock.t.Fatalf("RepositoryMock.GetById mock is already set by ExpectParams functions")
	}

	mmGetById.defaultExpectation.params = &RepositoryMockGetByIdParams{ctx, orderID}
	mmGetById.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetById.expectations {
		if minimock.Equal(e.params, mmGetById.defaultExpectation.params) {
			mmGetById.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetById.defaultExpectation.params)
		}
	}

	return mmGetById
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetById
func (mmGetById *mRepositoryMockGetById) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("RepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &RepositoryMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("RepositoryMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &RepositoryMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetById.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetById
}

// ExpectOrderIDParam2 sets up expected param orderID for Repository.GetById
func (mmGetById *mRepositoryMockGetById) ExpectOrderIDParam2(orderID int64) *mRepositoryMockGetById {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("RepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &RepositoryMockGetByIdExpectation{}
	}

	if mmGetById.defaultExpectation.params != nil {
		mmGetById.mock.t.Fatalf("RepositoryMock.GetById mock is already set by Expect")
	}

	if mmGetById.defaultExpectation.paramPtrs == nil {
		mmGetById.defaultExpectation.paramPtrs = &RepositoryMockGetByIdParamPtrs{}
	}
	mmGetById.defaultExpectation.paramPtrs.orderID = &orderID
	mmGetById.defaultExpectation.expectationOrigins.originOrderID = minimock.CallerInfo(1)

	return mmGetById
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetById
func (mmGetById *mRepositoryMockGetById) Inspect(f func(ctx context.Context, orderID int64)) *mRepositoryMockGetById {
	if mmGetById.mock.inspectFuncGetById != nil {
		mmGetById.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetById")
	}

	mmGetById.mock.inspectFuncGetById = f

	return mmGetById
}

// Return sets up results that will be returned by Repository.GetById
func (mmGetById *mRepositoryMockGetById) Return(op1 *model.Order, err error) *RepositoryMock {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("RepositoryMock.GetById mock is already set by Set")
	}

	if mmGetById.defaultExpectation == nil {
		mmGetById.defaultExpectation = &RepositoryMockGetByIdExpectation{mock: mmGetById.mock}
	}
	mmGetById.defaultExpectation.results = &RepositoryMockGetByIdResults{op1, err}
	mmGetById.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// Set uses given function f to mock the Repository.GetById method
func (mmGetById *mRepositoryMockGetById) Set(f func(ctx context.Context, orderID int64) (op1 *model.Order, err error)) *RepositoryMock {
	if mmGetById.defaultExpectation != nil {
		mmGetById.mock.t.Fatalf("Default expectation is already set for the Repository.GetById method")
	}

	if len(mmGetById.expectations) > 0 {
		mmGetById.mock.t.Fatalf("Some expectations are already set for the Repository.GetById method")
	}

	mmGetById.mock.funcGetById = f
	mmGetById.mock.funcGetByIdOrigin = minimock.CallerInfo(1)
	return mmGetById.mock
}

// When sets expectation for the Repository.GetById which will trigger the result defined by the following
// Then helper
func (mmGetById *mRepositoryMockGetById) When(ctx context.Context, orderID int64) *RepositoryMockGetByIdExpectation {
	if mmGetById.mock.funcGetById != nil {
		mmGetById.mock.t.Fatalf("RepositoryMock.GetById mock is already set by Set")
	}

	expectation := &RepositoryMockGetByIdExpectation{
		mock:               mmGetById.mock,
		params:             &RepositoryMockGetByIdParams{ctx, orderID},
		expectationOrigins: RepositoryMockGetByIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetById.expectations = append(mmGetById.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetById return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetByIdExpectation) Then(op1 *model.Order, err error) *RepositoryMock {
	e.results = &RepositoryMockGetByIdResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.GetById should be invoked
func (mmGetById *mRepositoryMockGetById) Times(n uint64) *mRepositoryMockGetById {
	if n == 0 {
		mmGetById.mock.t.Fatalf("Times of RepositoryMock.GetById mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetById.expectedInvocations, n)
	mmGetById.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetById
}

func (mmGetById *mRepositoryMockGetById) invocationsDone() bool {
	if len(mmGetById.expectations) == 0 && mmGetById.defaultExpectation == nil && mmGetById.mock.funcGetById == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetById.mock.afterGetByIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetById.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetById implements mm_orderservice.Repository
func (mmGetById *RepositoryMock) GetById(ctx context.Context, orderID int64) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmGetById.beforeGetByIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetById.afterGetByIdCounter, 1)

	mmGetById.t.Helper()

	if mmGetById.inspectFuncGetById != nil {
		mmGetById.inspectFuncGetById(ctx, orderID)
	}

	mm_params := RepositoryMockGetByIdParams{ctx, orderID}

	// Record call args
	mmGetById.GetByIdMock.mutex.Lock()
	mmGetById.GetByIdMock.callArgs = append(mmGetById.GetByIdMock.callArgs, &mm_params)
	mmGetById.GetByIdMock.mutex.Unlock()

	for _, e := range mmGetById.GetByIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmGetById.GetByIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetById.GetByIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetById.GetByIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetById.GetByIdMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetByIdParams{ctx, orderID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetById.t.Errorf("RepositoryMock.GetById got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.orderID != nil && !minimock.Equal(*mm_want_ptrs.orderID, mm_got.orderID) {
				mmGetById.t.Errorf("RepositoryMock.GetById got unexpected parameter orderID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.originOrderID, *mm_want_ptrs.orderID, mm_got.orderID, minimock.Diff(*mm_want_ptrs.orderID, mm_got.orderID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetById.t.Errorf("RepositoryMock.GetById got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetById.GetByIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetById.GetByIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetById.t.Fatal("No results are set for the RepositoryMock.GetById")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetById.funcGetById != nil {
		return mmGetById.funcGetById(ctx, orderID)
	}
	mmGetById.t.Fatalf("Unexpected call to RepositoryMock.GetById. %v %v", ctx, orderID)
	return
}

// GetByIdAfterCounter returns a count of finished RepositoryMock.GetById invocations
func (mmGetById *RepositoryMock) GetByIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.afterGetByIdCounter)
}

// GetByIdBeforeCounter returns a count of RepositoryMock.GetById invocations
func (mmGetById *RepositoryMock) GetByIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetById.beforeGetByIdCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetById.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetById *mRepositoryMockGetById) Calls() []*RepositoryMockGetByIdParams {
	mmGetById.mutex.RLock()

	argCopy := make([]*RepositoryMockGetByIdParams, len(mmGetById.callArgs))
	copy(argCopy, mmGetById.callArgs)

	mmGetById.mutex.RUnlock()

	return argCopy
}

// MinimockGetByIdDone returns true if the count of the GetById invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetByIdDone() bool {
	if m.GetByIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetByIdMock.invocationsDone()
}

// MinimockGetByIdInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetByIdInspect() {
	for _, e := range m.GetByIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetById at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetByIdCounter := mm_atomic.LoadUint64(&m.afterGetByIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetByIdMock.defaultExpectation != nil && afterGetByIdCounter < 1 {
		if m.GetByIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetById at\n%s", m.GetByIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetById at\n%s with params: %#v", m.GetByIdMock.defaultExpectation.expectationOrigins.origin, *m.GetByIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetById != nil && afterGetByIdCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetById at\n%s", m.funcGetByIdOrigin)
	}

	if !m.GetByIdMock.invocationsDone() && afterGetByIdCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetById at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetByIdMock.expectedInvocations), m.GetByIdMock.expectedInvocationsOrigin, afterGetByIdCounter)
	}
}

type mRepositoryMockSaveOrder struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockSaveOrderExpectation
	expectations       []*RepositoryMockSaveOrderExpectation

	callArgs []*RepositoryMockSaveOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockSaveOrderExpectation specifies expectation struct of the Repository.SaveOrder
type RepositoryMockSaveOrderExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockSaveOrderParams
	paramPtrs          *RepositoryMockSaveOrderParamPtrs
	expectationOrigins RepositoryMockSaveOrderExpectationOrigins
	results            *RepositoryMockSaveOrderResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockSaveOrderParams contains parameters of the Repository.SaveOrder
type RepositoryMockSaveOrderParams struct {
	ctx   context.Context
	order *model.Order
}

// RepositoryMockSaveOrderParamPtrs contains pointers to parameters of the Repository.SaveOrder
type RepositoryMockSaveOrderParamPtrs struct {
	ctx   *context.Context
	order **model.Order
}

// RepositoryMockSaveOrderResults contains results of the Repository.SaveOrder
type RepositoryMockSaveOrderResults struct {
	op1 *model.Order
	err error
}

// RepositoryMockSaveOrderOrigins contains origins of expectations of the Repository.SaveOrder
type RepositoryMockSaveOrderExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveOrder *mRepositoryMockSaveOrder) Optional() *mRepositoryMockSaveOrder {
	mmSaveOrder.optional = true
	return mmSaveOrder
}

// Expect sets up expected params for Repository.SaveOrder
func (mmSaveOrder *mRepositoryMockSaveOrder) Expect(ctx context.Context, order *model.Order) *mRepositoryMockSaveOrder {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("RepositoryMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &RepositoryMockSaveOrderExpectation{}
	}

	if mmSaveOrder.defaultExpectation.paramPtrs != nil {
		mmSaveOrder.mock.t.Fatalf("RepositoryMock.SaveOrder mock is already set by ExpectParams functions")
	}

	mmSaveOrder.defaultExpectation.params = &RepositoryMockSaveOrderParams{ctx, order}
	mmSaveOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveOrder.expectations {
		if minimock.Equal(e.params, mmSaveOrder.defaultExpectation.params) {
			mmSaveOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveOrder.defaultExpectation.params)
		}
	}

	return mmSaveOrder
}

// ExpectCtxParam1 sets up expected param ctx for Repository.SaveOrder
func (mmSaveOrder *mRepositoryMockSaveOrder) ExpectCtxParam1(ctx context.Context) *mRepositoryMockSaveOrder {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("RepositoryMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &RepositoryMockSaveOrderExpectation{}
	}

	if mmSaveOrder.defaultExpectation.params != nil {
		mmSaveOrder.mock.t.Fatalf("RepositoryMock.SaveOrder mock is already set by Expect")
	}

	if mmSaveOrder.defaultExpectation.paramPtrs == nil {
		mmSaveOrder.defaultExpectation.paramPtrs = &RepositoryMockSaveOrderParamPtrs{}
	}
	mmSaveOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmSaveOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSaveOrder
}

// ExpectOrderParam2 sets up expected param order for Repository.SaveOrder
func (mmSaveOrder *mRepositoryMockSaveOrder) ExpectOrderParam2(order *model.Order) *mRepositoryMockSaveOrder {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("RepositoryMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &RepositoryMockSaveOrderExpectation{}
	}

	if mmSaveOrder.defaultExpectation.params != nil {
		mmSaveOrder.mock.t.Fatalf("RepositoryMock.SaveOrder mock is already set by Expect")
	}

	if mmSaveOrder.defaultExpectation.paramPtrs == nil {
		mmSaveOrder.defaultExpectation.paramPtrs = &RepositoryMockSaveOrderParamPtrs{}
	}
	mmSaveOrder.defaultExpectation.paramPtrs.order = &order
	mmSaveOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmSaveOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.SaveOrder
func (mmSaveOrder *mRepositoryMockSaveOrder) Inspect(f func(ctx context.Context, order *model.Order)) *mRepositoryMockSaveOrder {
	if mmSaveOrder.mock.inspectFuncSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.SaveOrder")
	}

	mmSaveOrder.mock.inspectFuncSaveOrder = f

	return mmSaveOrder
}

// Return sets up results that will be returned by Repository.SaveOrder
func (mmSaveOrder *mRepositoryMockSaveOrder) Return(op1 *model.Order, err error) *RepositoryMock {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("RepositoryMock.SaveOrder mock is already set by Set")
	}

	if mmSaveOrder.defaultExpectation == nil {
		mmSaveOrder.defaultExpectation = &RepositoryMockSaveOrderExpectation{mock: mmSaveOrder.mock}
	}
	mmSaveOrder.defaultExpectation.results = &RepositoryMockSaveOrderResults{op1, err}
	mmSaveOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveOrder.mock
}

// Set uses given function f to mock the Repository.SaveOrder method
func (mmSaveOrder *mRepositoryMockSaveOrder) Set(f func(ctx context.Context, order *model.Order) (op1 *model.Order, err error)) *RepositoryMock {
	if mmSaveOrder.defaultExpectation != nil {
		mmSaveOrder.mock.t.Fatalf("Default expectation is already set for the Repository.SaveOrder method")
	}

	if len(mmSaveOrder.expectations) > 0 {
		mmSaveOrder.mock.t.Fatalf("Some expectations are already set for the Repository.SaveOrder method")
	}

	mmSaveOrder.mock.funcSaveOrder = f
	mmSaveOrder.mock.funcSaveOrderOrigin = minimock.CallerInfo(1)
	return mmSaveOrder.mock
}

// When sets expectation for the Repository.SaveOrder which will trigger the result defined by the following
// Then helper
func (mmSaveOrder *mRepositoryMockSaveOrder) When(ctx context.Context, order *model.Order) *RepositoryMockSaveOrderExpectation {
	if mmSaveOrder.mock.funcSaveOrder != nil {
		mmSaveOrder.mock.t.Fatalf("RepositoryMock.SaveOrder mock is already set by Set")
	}

	expectation := &RepositoryMockSaveOrderExpectation{
		mock:               mmSaveOrder.mock,
		params:             &RepositoryMockSaveOrderParams{ctx, order},
		expectationOrigins: RepositoryMockSaveOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveOrder.expectations = append(mmSaveOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.SaveOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockSaveOrderExpectation) Then(op1 *model.Order, err error) *RepositoryMock {
	e.results = &RepositoryMockSaveOrderResults{op1, err}
	return e.mock
}

// Times sets number of times Repository.SaveOrder should be invoked
func (mmSaveOrder *mRepositoryMockSaveOrder) Times(n uint64) *mRepositoryMockSaveOrder {
	if n == 0 {
		mmSaveOrder.mock.t.Fatalf("Times of RepositoryMock.SaveOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveOrder.expectedInvocations, n)
	mmSaveOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveOrder
}

func (mmSaveOrder *mRepositoryMockSaveOrder) invocationsDone() bool {
	if len(mmSaveOrder.expectations) == 0 && mmSaveOrder.defaultExpectation == nil && mmSaveOrder.mock.funcSaveOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveOrder.mock.afterSaveOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveOrder implements mm_orderservice.Repository
func (mmSaveOrder *RepositoryMock) SaveOrder(ctx context.Context, order *model.Order) (op1 *model.Order, err error) {
	mm_atomic.AddUint64(&mmSaveOrder.beforeSaveOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveOrder.afterSaveOrderCounter, 1)

	mmSaveOrder.t.Helper()

	if mmSaveOrder.inspectFuncSaveOrder != nil {
		mmSaveOrder.inspectFuncSaveOrder(ctx, order)
	}

	mm_params := RepositoryMockSaveOrderParams{ctx, order}

	// Record call args
	mmSaveOrder.SaveOrderMock.mutex.Lock()
	mmSaveOrder.SaveOrderMock.callArgs = append(mmSaveOrder.SaveOrderMock.callArgs, &mm_params)
	mmSaveOrder.SaveOrderMock.mutex.Unlock()

	for _, e := range mmSaveOrder.SaveOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.op1, e.results.err
		}
	}

	if mmSaveOrder.SaveOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveOrder.SaveOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveOrder.SaveOrderMock.defaultExpectation.params
		mm_want_ptrs := mmSaveOrder.SaveOrderMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockSaveOrderParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSaveOrder.t.Errorf("RepositoryMock.SaveOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveOrder.SaveOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmSaveOrder.t.Errorf("RepositoryMock.SaveOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveOrder.SaveOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveOrder.t.Errorf("RepositoryMock.SaveOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveOrder.SaveOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveOrder.SaveOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveOrder.t.Fatal("No results are set for the RepositoryMock.SaveOrder")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmSaveOrder.funcSaveOrder != nil {
		return mmSaveOrder.funcSaveOrder(ctx, order)
	}
	mmSaveOrder.t.Fatalf("Unexpected call to RepositoryMock.SaveOrder. %v %v", ctx, order)
	return
}

// SaveOrderAfterCounter returns a count of finished RepositoryMock.SaveOrder invocations
func (mmSaveOrder *RepositoryMock) SaveOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrder.afterSaveOrderCounter)
}

// SaveOrderBeforeCounter returns a count of RepositoryMock.SaveOrder invocations
func (mmSaveOrder *RepositoryMock) SaveOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveOrder.beforeSaveOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.SaveOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveOrder *mRepositoryMockSaveOrder) Calls() []*RepositoryMockSaveOrderParams {
	mmSaveOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockSaveOrderParams, len(mmSaveOrder.callArgs))
	copy(argCopy, mmSaveOrder.callArgs)

	mmSaveOrder.mutex.RUnlock()

	return argCopy
}

// MinimockSaveOrderDone returns true if the count of the SaveOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockSaveOrderDone() bool {
	if m.SaveOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveOrderMock.invocationsDone()
}

// MinimockSaveOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockSaveOrderInspect() {
	for _, e := range m.SaveOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.SaveOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveOrderCounter := mm_atomic.LoadUint64(&m.afterSaveOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveOrderMock.defaultExpectation != nil && afterSaveOrderCounter < 1 {
		if m.SaveOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.SaveOrder at\n%s", m.SaveOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.SaveOrder at\n%s with params: %#v", m.SaveOrderMock.defaultExpectation.expectationOrigins.origin, *m.SaveOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveOrder != nil && afterSaveOrderCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.SaveOrder at\n%s", m.funcSaveOrderOrigin)
	}

	if !m.SaveOrderMock.invocationsDone() && afterSaveOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.SaveOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveOrderMock.expectedInvocations), m.SaveOrderMock.expectedInvocationsOrigin, afterSaveOrderCounter)
	}
}

type mRepositoryMockUpdateOrder struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateOrderExpectation
	expectations       []*RepositoryMockUpdateOrderExpectation

	callArgs []*RepositoryMockUpdateOrderParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateOrderExpectation specifies expectation struct of the Repository.UpdateOrder
type RepositoryMockUpdateOrderExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateOrderParams
	paramPtrs          *RepositoryMockUpdateOrderParamPtrs
	expectationOrigins RepositoryMockUpdateOrderExpectationOrigins
	results            *RepositoryMockUpdateOrderResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateOrderParams contains parameters of the Repository.UpdateOrder
type RepositoryMockUpdateOrderParams struct {
	ctx   context.Context
	order *model.Order
}

// RepositoryMockUpdateOrderParamPtrs contains pointers to parameters of the Repository.UpdateOrder
type RepositoryMockUpdateOrderParamPtrs struct {
	ctx   *context.Context
	order **model.Order
}

// RepositoryMockUpdateOrderResults contains results of the Repository.UpdateOrder
type RepositoryMockUpdateOrderResults struct {
	err error
}

// RepositoryMockUpdateOrderOrigins contains origins of expectations of the Repository.UpdateOrder
type RepositoryMockUpdateOrderExpectationOrigins struct {
	origin      string
	originCtx   string
	originOrder string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Optional() *mRepositoryMockUpdateOrder {
	mmUpdateOrder.optional = true
	return mmUpdateOrder
}

// Expect sets up expected params for Repository.UpdateOrder
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Expect(ctx context.Context, order *model.Order) *mRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &RepositoryMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by ExpectParams functions")
	}

	mmUpdateOrder.defaultExpectation.params = &RepositoryMockUpdateOrderParams{ctx, order}
	mmUpdateOrder.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateOrder.expectations {
		if minimock.Equal(e.params, mmUpdateOrder.defaultExpectation.params) {
			mmUpdateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrder.defaultExpectation.params)
		}
	}

	return mmUpdateOrder
}

// ExpectCtxParam1 sets up expected param ctx for Repository.UpdateOrder
func (mmUpdateOrder *mRepositoryMockUpdateOrder) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &RepositoryMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &RepositoryMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateOrder.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateOrder
}

// ExpectOrderParam2 sets up expected param order for Repository.UpdateOrder
func (mmUpdateOrder *mRepositoryMockUpdateOrder) ExpectOrderParam2(order *model.Order) *mRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &RepositoryMockUpdateOrderExpectation{}
	}

	if mmUpdateOrder.defaultExpectation.params != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Expect")
	}

	if mmUpdateOrder.defaultExpectation.paramPtrs == nil {
		mmUpdateOrder.defaultExpectation.paramPtrs = &RepositoryMockUpdateOrderParamPtrs{}
	}
	mmUpdateOrder.defaultExpectation.paramPtrs.order = &order
	mmUpdateOrder.defaultExpectation.expectationOrigins.originOrder = minimock.CallerInfo(1)

	return mmUpdateOrder
}

// Inspect accepts an inspector function that has same arguments as the Repository.UpdateOrder
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Inspect(f func(ctx context.Context, order *model.Order)) *mRepositoryMockUpdateOrder {
	if mmUpdateOrder.mock.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("Inspect function is already set for RepositoryMock.UpdateOrder")
	}

	mmUpdateOrder.mock.inspectFuncUpdateOrder = f

	return mmUpdateOrder
}

// Return sets up results that will be returned by Repository.UpdateOrder
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Return(err error) *RepositoryMock {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &RepositoryMockUpdateOrderExpectation{mock: mmUpdateOrder.mock}
	}
	mmUpdateOrder.defaultExpectation.results = &RepositoryMockUpdateOrderResults{err}
	mmUpdateOrder.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder.mock
}

// Set uses given function f to mock the Repository.UpdateOrder method
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Set(f func(ctx context.Context, order *model.Order) (err error)) *RepositoryMock {
	if mmUpdateOrder.defaultExpectation != nil {
		mmUpdateOrder.mock.t.Fatalf("Default expectation is already set for the Repository.UpdateOrder method")
	}

	if len(mmUpdateOrder.expectations) > 0 {
		mmUpdateOrder.mock.t.Fatalf("Some expectations are already set for the Repository.UpdateOrder method")
	}

	mmUpdateOrder.mock.funcUpdateOrder = f
	mmUpdateOrder.mock.funcUpdateOrderOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder.mock
}

// When sets expectation for the Repository.UpdateOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateOrder *mRepositoryMockUpdateOrder) When(ctx context.Context, order *model.Order) *RepositoryMockUpdateOrderExpectation {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepositoryMock.UpdateOrder mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateOrderExpectation{
		mock:               mmUpdateOrder.mock,
		params:             &RepositoryMockUpdateOrderParams{ctx, order},
		expectationOrigins: RepositoryMockUpdateOrderExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateOrder.expectations = append(mmUpdateOrder.expectations, expectation)
	return expectation
}

// Then sets up Repository.UpdateOrder return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateOrderExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateOrderResults{err}
	return e.mock
}

// Times sets number of times Repository.UpdateOrder should be invoked
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Times(n uint64) *mRepositoryMockUpdateOrder {
	if n == 0 {
		mmUpdateOrder.mock.t.Fatalf("Times of RepositoryMock.UpdateOrder mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateOrder.expectedInvocations, n)
	mmUpdateOrder.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateOrder
}

func (mmUpdateOrder *mRepositoryMockUpdateOrder) invocationsDone() bool {
	if len(mmUpdateOrder.expectations) == 0 && mmUpdateOrder.defaultExpectation == nil && mmUpdateOrder.mock.funcUpdateOrder == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateOrder.mock.afterUpdateOrderCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateOrder.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateOrder implements mm_orderservice.Repository
func (mmUpdateOrder *RepositoryMock) UpdateOrder(ctx context.Context, order *model.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrder.beforeUpdateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrder.afterUpdateOrderCounter, 1)

	mmUpdateOrder.t.Helper()

	if mmUpdateOrder.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.inspectFuncUpdateOrder(ctx, order)
	}

	mm_params := RepositoryMockUpdateOrderParams{ctx, order}

	// Record call args
	mmUpdateOrder.UpdateOrderMock.mutex.Lock()
	mmUpdateOrder.UpdateOrderMock.callArgs = append(mmUpdateOrder.UpdateOrderMock.callArgs, &mm_params)
	mmUpdateOrder.UpdateOrderMock.mutex.Unlock()

	for _, e := range mmUpdateOrder.UpdateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrder.UpdateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrder.UpdateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrder.UpdateOrderMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateOrder.UpdateOrderMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateOrderParams{ctx, order}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateOrder.t.Errorf("RepositoryMock.UpdateOrder got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.order != nil && !minimock.Equal(*mm_want_ptrs.order, mm_got.order) {
				mmUpdateOrder.t.Errorf("RepositoryMock.UpdateOrder got unexpected parameter order, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.originOrder, *mm_want_ptrs.order, mm_got.order, minimock.Diff(*mm_want_ptrs.order, mm_got.order))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrder.t.Errorf("RepositoryMock.UpdateOrder got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateOrder.UpdateOrderMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrder.UpdateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrder.t.Fatal("No results are set for the RepositoryMock.UpdateOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateOrder.funcUpdateOrder != nil {
		return mmUpdateOrder.funcUpdateOrder(ctx, order)
	}
	mmUpdateOrder.t.Fatalf("Unexpected call to RepositoryMock.UpdateOrder. %v %v", ctx, order)
	return
}

// UpdateOrderAfterCounter returns a count of finished RepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *RepositoryMock) UpdateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.afterUpdateOrderCounter)
}

// UpdateOrderBeforeCounter returns a count of RepositoryMock.UpdateOrder invocations
func (mmUpdateOrder *RepositoryMock) UpdateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.beforeUpdateOrderCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.UpdateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrder *mRepositoryMockUpdateOrder) Calls() []*RepositoryMockUpdateOrderParams {
	mmUpdateOrder.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateOrderParams, len(mmUpdateOrder.callArgs))
	copy(argCopy, mmUpdateOrder.callArgs)

	mmUpdateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderDone returns true if the count of the UpdateOrder invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateOrderDone() bool {
	if m.UpdateOrderMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateOrderMock.invocationsDone()
}

// MinimockUpdateOrderInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateOrderInspect() {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.UpdateOrder at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateOrderCounter := mm_atomic.LoadUint64(&m.afterUpdateOrderCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && afterUpdateOrderCounter < 1 {
		if m.UpdateOrderMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.UpdateOrder at\n%s", m.UpdateOrderMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.UpdateOrder at\n%s with params: %#v", m.UpdateOrderMock.defaultExpectation.expectationOrigins.origin, *m.UpdateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && afterUpdateOrderCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.UpdateOrder at\n%s", m.funcUpdateOrderOrigin)
	}

	if !m.UpdateOrderMock.invocationsDone() && afterUpdateOrderCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.UpdateOrder at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateOrderMock.expectedInvocations), m.UpdateOrderMock.expectedInvocationsOrigin, afterUpdateOrderCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetByIdInspect()

			m.MinimockSaveOrderInspect()

			m.MinimockUpdateOrderInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetByIdDone() &&
		m.MinimockSaveOrderDone() &&
		m.MinimockUpdateOrderDone()
}
