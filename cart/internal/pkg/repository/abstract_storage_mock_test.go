// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package repository

//go:generate minimock -i route256/cart/internal/pkg/repository.AbstractStorage -o abstract_storage_mock_test.go -n AbstractStorageMock -p repository

import (
	"route256/cart/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AbstractStorageMock implements AbstractStorage
type AbstractStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(id model.UserId, item model.CartItem)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(id model.UserId, item model.CartItem)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mAbstractStorageMockAddItem

	funcGetCart          func(id model.UserId) (m1 map[model.SKU]model.CartItem, err error)
	funcGetCartOrigin    string
	inspectFuncGetCart   func(id model.UserId)
	afterGetCartCounter  uint64
	beforeGetCartCounter uint64
	GetCartMock          mAbstractStorageMockGetCart

	funcRemoveByUserId          func(id model.UserId) (err error)
	funcRemoveByUserIdOrigin    string
	inspectFuncRemoveByUserId   func(id model.UserId)
	afterRemoveByUserIdCounter  uint64
	beforeRemoveByUserIdCounter uint64
	RemoveByUserIdMock          mAbstractStorageMockRemoveByUserId

	funcRemoveItem          func(id model.UserId, sku model.SKU) (err error)
	funcRemoveItemOrigin    string
	inspectFuncRemoveItem   func(id model.UserId, sku model.SKU)
	afterRemoveItemCounter  uint64
	beforeRemoveItemCounter uint64
	RemoveItemMock          mAbstractStorageMockRemoveItem
}

// NewAbstractStorageMock returns a mock for AbstractStorage
func NewAbstractStorageMock(t minimock.Tester) *AbstractStorageMock {
	m := &AbstractStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mAbstractStorageMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*AbstractStorageMockAddItemParams{}

	m.GetCartMock = mAbstractStorageMockGetCart{mock: m}
	m.GetCartMock.callArgs = []*AbstractStorageMockGetCartParams{}

	m.RemoveByUserIdMock = mAbstractStorageMockRemoveByUserId{mock: m}
	m.RemoveByUserIdMock.callArgs = []*AbstractStorageMockRemoveByUserIdParams{}

	m.RemoveItemMock = mAbstractStorageMockRemoveItem{mock: m}
	m.RemoveItemMock.callArgs = []*AbstractStorageMockRemoveItemParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAbstractStorageMockAddItem struct {
	optional           bool
	mock               *AbstractStorageMock
	defaultExpectation *AbstractStorageMockAddItemExpectation
	expectations       []*AbstractStorageMockAddItemExpectation

	callArgs []*AbstractStorageMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AbstractStorageMockAddItemExpectation specifies expectation struct of the AbstractStorage.AddItem
type AbstractStorageMockAddItemExpectation struct {
	mock               *AbstractStorageMock
	params             *AbstractStorageMockAddItemParams
	paramPtrs          *AbstractStorageMockAddItemParamPtrs
	expectationOrigins AbstractStorageMockAddItemExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// AbstractStorageMockAddItemParams contains parameters of the AbstractStorage.AddItem
type AbstractStorageMockAddItemParams struct {
	id   model.UserId
	item model.CartItem
}

// AbstractStorageMockAddItemParamPtrs contains pointers to parameters of the AbstractStorage.AddItem
type AbstractStorageMockAddItemParamPtrs struct {
	id   *model.UserId
	item *model.CartItem
}

// AbstractStorageMockAddItemOrigins contains origins of expectations of the AbstractStorage.AddItem
type AbstractStorageMockAddItemExpectationOrigins struct {
	origin     string
	originId   string
	originItem string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mAbstractStorageMockAddItem) Optional() *mAbstractStorageMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for AbstractStorage.AddItem
func (mmAddItem *mAbstractStorageMockAddItem) Expect(id model.UserId, item model.CartItem) *mAbstractStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("AbstractStorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &AbstractStorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("AbstractStorageMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &AbstractStorageMockAddItemParams{id, item}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectIdParam1 sets up expected param id for AbstractStorage.AddItem
func (mmAddItem *mAbstractStorageMockAddItem) ExpectIdParam1(id model.UserId) *mAbstractStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("AbstractStorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &AbstractStorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("AbstractStorageMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &AbstractStorageMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.id = &id
	mmAddItem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmAddItem
}

// ExpectItemParam2 sets up expected param item for AbstractStorage.AddItem
func (mmAddItem *mAbstractStorageMockAddItem) ExpectItemParam2(item model.CartItem) *mAbstractStorageMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("AbstractStorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &AbstractStorageMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("AbstractStorageMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &AbstractStorageMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.item = &item
	mmAddItem.defaultExpectation.expectationOrigins.originItem = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the AbstractStorage.AddItem
func (mmAddItem *mAbstractStorageMockAddItem) Inspect(f func(id model.UserId, item model.CartItem)) *mAbstractStorageMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for AbstractStorageMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by AbstractStorage.AddItem
func (mmAddItem *mAbstractStorageMockAddItem) Return() *AbstractStorageMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("AbstractStorageMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &AbstractStorageMockAddItemExpectation{mock: mmAddItem.mock}
	}

	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the AbstractStorage.AddItem method
func (mmAddItem *mAbstractStorageMockAddItem) Set(f func(id model.UserId, item model.CartItem)) *AbstractStorageMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the AbstractStorage.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the AbstractStorage.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Times sets number of times AbstractStorage.AddItem should be invoked
func (mmAddItem *mAbstractStorageMockAddItem) Times(n uint64) *mAbstractStorageMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of AbstractStorageMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mAbstractStorageMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements AbstractStorage
func (mmAddItem *AbstractStorageMock) AddItem(id model.UserId, item model.CartItem) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(id, item)
	}

	mm_params := AbstractStorageMockAddItemParams{id, item}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := AbstractStorageMockAddItemParams{id, item}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmAddItem.t.Errorf("AbstractStorageMock.AddItem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.item != nil && !minimock.Equal(*mm_want_ptrs.item, mm_got.item) {
				mmAddItem.t.Errorf("AbstractStorageMock.AddItem got unexpected parameter item, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originItem, *mm_want_ptrs.item, mm_got.item, minimock.Diff(*mm_want_ptrs.item, mm_got.item))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("AbstractStorageMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddItem.funcAddItem != nil {
		mmAddItem.funcAddItem(id, item)
		return
	}
	mmAddItem.t.Fatalf("Unexpected call to AbstractStorageMock.AddItem. %v %v", id, item)

}

// AddItemAfterCounter returns a count of finished AbstractStorageMock.AddItem invocations
func (mmAddItem *AbstractStorageMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of AbstractStorageMock.AddItem invocations
func (mmAddItem *AbstractStorageMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to AbstractStorageMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mAbstractStorageMockAddItem) Calls() []*AbstractStorageMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*AbstractStorageMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *AbstractStorageMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *AbstractStorageMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AbstractStorageMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AbstractStorageMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AbstractStorageMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to AbstractStorageMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to AbstractStorageMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mAbstractStorageMockGetCart struct {
	optional           bool
	mock               *AbstractStorageMock
	defaultExpectation *AbstractStorageMockGetCartExpectation
	expectations       []*AbstractStorageMockGetCartExpectation

	callArgs []*AbstractStorageMockGetCartParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AbstractStorageMockGetCartExpectation specifies expectation struct of the AbstractStorage.GetCart
type AbstractStorageMockGetCartExpectation struct {
	mock               *AbstractStorageMock
	params             *AbstractStorageMockGetCartParams
	paramPtrs          *AbstractStorageMockGetCartParamPtrs
	expectationOrigins AbstractStorageMockGetCartExpectationOrigins
	results            *AbstractStorageMockGetCartResults
	returnOrigin       string
	Counter            uint64
}

// AbstractStorageMockGetCartParams contains parameters of the AbstractStorage.GetCart
type AbstractStorageMockGetCartParams struct {
	id model.UserId
}

// AbstractStorageMockGetCartParamPtrs contains pointers to parameters of the AbstractStorage.GetCart
type AbstractStorageMockGetCartParamPtrs struct {
	id *model.UserId
}

// AbstractStorageMockGetCartResults contains results of the AbstractStorage.GetCart
type AbstractStorageMockGetCartResults struct {
	m1  map[model.SKU]model.CartItem
	err error
}

// AbstractStorageMockGetCartOrigins contains origins of expectations of the AbstractStorage.GetCart
type AbstractStorageMockGetCartExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCart *mAbstractStorageMockGetCart) Optional() *mAbstractStorageMockGetCart {
	mmGetCart.optional = true
	return mmGetCart
}

// Expect sets up expected params for AbstractStorage.GetCart
func (mmGetCart *mAbstractStorageMockGetCart) Expect(id model.UserId) *mAbstractStorageMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("AbstractStorageMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &AbstractStorageMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.paramPtrs != nil {
		mmGetCart.mock.t.Fatalf("AbstractStorageMock.GetCart mock is already set by ExpectParams functions")
	}

	mmGetCart.defaultExpectation.params = &AbstractStorageMockGetCartParams{id}
	mmGetCart.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCart.expectations {
		if minimock.Equal(e.params, mmGetCart.defaultExpectation.params) {
			mmGetCart.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCart.defaultExpectation.params)
		}
	}

	return mmGetCart
}

// ExpectIdParam1 sets up expected param id for AbstractStorage.GetCart
func (mmGetCart *mAbstractStorageMockGetCart) ExpectIdParam1(id model.UserId) *mAbstractStorageMockGetCart {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("AbstractStorageMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &AbstractStorageMockGetCartExpectation{}
	}

	if mmGetCart.defaultExpectation.params != nil {
		mmGetCart.mock.t.Fatalf("AbstractStorageMock.GetCart mock is already set by Expect")
	}

	if mmGetCart.defaultExpectation.paramPtrs == nil {
		mmGetCart.defaultExpectation.paramPtrs = &AbstractStorageMockGetCartParamPtrs{}
	}
	mmGetCart.defaultExpectation.paramPtrs.id = &id
	mmGetCart.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetCart
}

// Inspect accepts an inspector function that has same arguments as the AbstractStorage.GetCart
func (mmGetCart *mAbstractStorageMockGetCart) Inspect(f func(id model.UserId)) *mAbstractStorageMockGetCart {
	if mmGetCart.mock.inspectFuncGetCart != nil {
		mmGetCart.mock.t.Fatalf("Inspect function is already set for AbstractStorageMock.GetCart")
	}

	mmGetCart.mock.inspectFuncGetCart = f

	return mmGetCart
}

// Return sets up results that will be returned by AbstractStorage.GetCart
func (mmGetCart *mAbstractStorageMockGetCart) Return(m1 map[model.SKU]model.CartItem, err error) *AbstractStorageMock {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("AbstractStorageMock.GetCart mock is already set by Set")
	}

	if mmGetCart.defaultExpectation == nil {
		mmGetCart.defaultExpectation = &AbstractStorageMockGetCartExpectation{mock: mmGetCart.mock}
	}
	mmGetCart.defaultExpectation.results = &AbstractStorageMockGetCartResults{m1, err}
	mmGetCart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// Set uses given function f to mock the AbstractStorage.GetCart method
func (mmGetCart *mAbstractStorageMockGetCart) Set(f func(id model.UserId) (m1 map[model.SKU]model.CartItem, err error)) *AbstractStorageMock {
	if mmGetCart.defaultExpectation != nil {
		mmGetCart.mock.t.Fatalf("Default expectation is already set for the AbstractStorage.GetCart method")
	}

	if len(mmGetCart.expectations) > 0 {
		mmGetCart.mock.t.Fatalf("Some expectations are already set for the AbstractStorage.GetCart method")
	}

	mmGetCart.mock.funcGetCart = f
	mmGetCart.mock.funcGetCartOrigin = minimock.CallerInfo(1)
	return mmGetCart.mock
}

// When sets expectation for the AbstractStorage.GetCart which will trigger the result defined by the following
// Then helper
func (mmGetCart *mAbstractStorageMockGetCart) When(id model.UserId) *AbstractStorageMockGetCartExpectation {
	if mmGetCart.mock.funcGetCart != nil {
		mmGetCart.mock.t.Fatalf("AbstractStorageMock.GetCart mock is already set by Set")
	}

	expectation := &AbstractStorageMockGetCartExpectation{
		mock:               mmGetCart.mock,
		params:             &AbstractStorageMockGetCartParams{id},
		expectationOrigins: AbstractStorageMockGetCartExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCart.expectations = append(mmGetCart.expectations, expectation)
	return expectation
}

// Then sets up AbstractStorage.GetCart return parameters for the expectation previously defined by the When method
func (e *AbstractStorageMockGetCartExpectation) Then(m1 map[model.SKU]model.CartItem, err error) *AbstractStorageMock {
	e.results = &AbstractStorageMockGetCartResults{m1, err}
	return e.mock
}

// Times sets number of times AbstractStorage.GetCart should be invoked
func (mmGetCart *mAbstractStorageMockGetCart) Times(n uint64) *mAbstractStorageMockGetCart {
	if n == 0 {
		mmGetCart.mock.t.Fatalf("Times of AbstractStorageMock.GetCart mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCart.expectedInvocations, n)
	mmGetCart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCart
}

func (mmGetCart *mAbstractStorageMockGetCart) invocationsDone() bool {
	if len(mmGetCart.expectations) == 0 && mmGetCart.defaultExpectation == nil && mmGetCart.mock.funcGetCart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCart.mock.afterGetCartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCart implements AbstractStorage
func (mmGetCart *AbstractStorageMock) GetCart(id model.UserId) (m1 map[model.SKU]model.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCart.beforeGetCartCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCart.afterGetCartCounter, 1)

	mmGetCart.t.Helper()

	if mmGetCart.inspectFuncGetCart != nil {
		mmGetCart.inspectFuncGetCart(id)
	}

	mm_params := AbstractStorageMockGetCartParams{id}

	// Record call args
	mmGetCart.GetCartMock.mutex.Lock()
	mmGetCart.GetCartMock.callArgs = append(mmGetCart.GetCartMock.callArgs, &mm_params)
	mmGetCart.GetCartMock.mutex.Unlock()

	for _, e := range mmGetCart.GetCartMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetCart.GetCartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCart.GetCartMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCart.GetCartMock.defaultExpectation.params
		mm_want_ptrs := mmGetCart.GetCartMock.defaultExpectation.paramPtrs

		mm_got := AbstractStorageMockGetCartParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetCart.t.Errorf("AbstractStorageMock.GetCart got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCart.t.Errorf("AbstractStorageMock.GetCart got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCart.GetCartMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCart.GetCartMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCart.t.Fatal("No results are set for the AbstractStorageMock.GetCart")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetCart.funcGetCart != nil {
		return mmGetCart.funcGetCart(id)
	}
	mmGetCart.t.Fatalf("Unexpected call to AbstractStorageMock.GetCart. %v", id)
	return
}

// GetCartAfterCounter returns a count of finished AbstractStorageMock.GetCart invocations
func (mmGetCart *AbstractStorageMock) GetCartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.afterGetCartCounter)
}

// GetCartBeforeCounter returns a count of AbstractStorageMock.GetCart invocations
func (mmGetCart *AbstractStorageMock) GetCartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCart.beforeGetCartCounter)
}

// Calls returns a list of arguments used in each call to AbstractStorageMock.GetCart.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCart *mAbstractStorageMockGetCart) Calls() []*AbstractStorageMockGetCartParams {
	mmGetCart.mutex.RLock()

	argCopy := make([]*AbstractStorageMockGetCartParams, len(mmGetCart.callArgs))
	copy(argCopy, mmGetCart.callArgs)

	mmGetCart.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartDone returns true if the count of the GetCart invocations corresponds
// the number of defined expectations
func (m *AbstractStorageMock) MinimockGetCartDone() bool {
	if m.GetCartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartMock.invocationsDone()
}

// MinimockGetCartInspect logs each unmet expectation
func (m *AbstractStorageMock) MinimockGetCartInspect() {
	for _, e := range m.GetCartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AbstractStorageMock.GetCart at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartCounter := mm_atomic.LoadUint64(&m.afterGetCartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartMock.defaultExpectation != nil && afterGetCartCounter < 1 {
		if m.GetCartMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AbstractStorageMock.GetCart at\n%s", m.GetCartMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AbstractStorageMock.GetCart at\n%s with params: %#v", m.GetCartMock.defaultExpectation.expectationOrigins.origin, *m.GetCartMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCart != nil && afterGetCartCounter < 1 {
		m.t.Errorf("Expected call to AbstractStorageMock.GetCart at\n%s", m.funcGetCartOrigin)
	}

	if !m.GetCartMock.invocationsDone() && afterGetCartCounter > 0 {
		m.t.Errorf("Expected %d calls to AbstractStorageMock.GetCart at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartMock.expectedInvocations), m.GetCartMock.expectedInvocationsOrigin, afterGetCartCounter)
	}
}

type mAbstractStorageMockRemoveByUserId struct {
	optional           bool
	mock               *AbstractStorageMock
	defaultExpectation *AbstractStorageMockRemoveByUserIdExpectation
	expectations       []*AbstractStorageMockRemoveByUserIdExpectation

	callArgs []*AbstractStorageMockRemoveByUserIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AbstractStorageMockRemoveByUserIdExpectation specifies expectation struct of the AbstractStorage.RemoveByUserId
type AbstractStorageMockRemoveByUserIdExpectation struct {
	mock               *AbstractStorageMock
	params             *AbstractStorageMockRemoveByUserIdParams
	paramPtrs          *AbstractStorageMockRemoveByUserIdParamPtrs
	expectationOrigins AbstractStorageMockRemoveByUserIdExpectationOrigins
	results            *AbstractStorageMockRemoveByUserIdResults
	returnOrigin       string
	Counter            uint64
}

// AbstractStorageMockRemoveByUserIdParams contains parameters of the AbstractStorage.RemoveByUserId
type AbstractStorageMockRemoveByUserIdParams struct {
	id model.UserId
}

// AbstractStorageMockRemoveByUserIdParamPtrs contains pointers to parameters of the AbstractStorage.RemoveByUserId
type AbstractStorageMockRemoveByUserIdParamPtrs struct {
	id *model.UserId
}

// AbstractStorageMockRemoveByUserIdResults contains results of the AbstractStorage.RemoveByUserId
type AbstractStorageMockRemoveByUserIdResults struct {
	err error
}

// AbstractStorageMockRemoveByUserIdOrigins contains origins of expectations of the AbstractStorage.RemoveByUserId
type AbstractStorageMockRemoveByUserIdExpectationOrigins struct {
	origin   string
	originId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) Optional() *mAbstractStorageMockRemoveByUserId {
	mmRemoveByUserId.optional = true
	return mmRemoveByUserId
}

// Expect sets up expected params for AbstractStorage.RemoveByUserId
func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) Expect(id model.UserId) *mAbstractStorageMockRemoveByUserId {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("AbstractStorageMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &AbstractStorageMockRemoveByUserIdExpectation{}
	}

	if mmRemoveByUserId.defaultExpectation.paramPtrs != nil {
		mmRemoveByUserId.mock.t.Fatalf("AbstractStorageMock.RemoveByUserId mock is already set by ExpectParams functions")
	}

	mmRemoveByUserId.defaultExpectation.params = &AbstractStorageMockRemoveByUserIdParams{id}
	mmRemoveByUserId.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveByUserId.expectations {
		if minimock.Equal(e.params, mmRemoveByUserId.defaultExpectation.params) {
			mmRemoveByUserId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveByUserId.defaultExpectation.params)
		}
	}

	return mmRemoveByUserId
}

// ExpectIdParam1 sets up expected param id for AbstractStorage.RemoveByUserId
func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) ExpectIdParam1(id model.UserId) *mAbstractStorageMockRemoveByUserId {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("AbstractStorageMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &AbstractStorageMockRemoveByUserIdExpectation{}
	}

	if mmRemoveByUserId.defaultExpectation.params != nil {
		mmRemoveByUserId.mock.t.Fatalf("AbstractStorageMock.RemoveByUserId mock is already set by Expect")
	}

	if mmRemoveByUserId.defaultExpectation.paramPtrs == nil {
		mmRemoveByUserId.defaultExpectation.paramPtrs = &AbstractStorageMockRemoveByUserIdParamPtrs{}
	}
	mmRemoveByUserId.defaultExpectation.paramPtrs.id = &id
	mmRemoveByUserId.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmRemoveByUserId
}

// Inspect accepts an inspector function that has same arguments as the AbstractStorage.RemoveByUserId
func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) Inspect(f func(id model.UserId)) *mAbstractStorageMockRemoveByUserId {
	if mmRemoveByUserId.mock.inspectFuncRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("Inspect function is already set for AbstractStorageMock.RemoveByUserId")
	}

	mmRemoveByUserId.mock.inspectFuncRemoveByUserId = f

	return mmRemoveByUserId
}

// Return sets up results that will be returned by AbstractStorage.RemoveByUserId
func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) Return(err error) *AbstractStorageMock {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("AbstractStorageMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &AbstractStorageMockRemoveByUserIdExpectation{mock: mmRemoveByUserId.mock}
	}
	mmRemoveByUserId.defaultExpectation.results = &AbstractStorageMockRemoveByUserIdResults{err}
	mmRemoveByUserId.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveByUserId.mock
}

// Set uses given function f to mock the AbstractStorage.RemoveByUserId method
func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) Set(f func(id model.UserId) (err error)) *AbstractStorageMock {
	if mmRemoveByUserId.defaultExpectation != nil {
		mmRemoveByUserId.mock.t.Fatalf("Default expectation is already set for the AbstractStorage.RemoveByUserId method")
	}

	if len(mmRemoveByUserId.expectations) > 0 {
		mmRemoveByUserId.mock.t.Fatalf("Some expectations are already set for the AbstractStorage.RemoveByUserId method")
	}

	mmRemoveByUserId.mock.funcRemoveByUserId = f
	mmRemoveByUserId.mock.funcRemoveByUserIdOrigin = minimock.CallerInfo(1)
	return mmRemoveByUserId.mock
}

// When sets expectation for the AbstractStorage.RemoveByUserId which will trigger the result defined by the following
// Then helper
func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) When(id model.UserId) *AbstractStorageMockRemoveByUserIdExpectation {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("AbstractStorageMock.RemoveByUserId mock is already set by Set")
	}

	expectation := &AbstractStorageMockRemoveByUserIdExpectation{
		mock:               mmRemoveByUserId.mock,
		params:             &AbstractStorageMockRemoveByUserIdParams{id},
		expectationOrigins: AbstractStorageMockRemoveByUserIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveByUserId.expectations = append(mmRemoveByUserId.expectations, expectation)
	return expectation
}

// Then sets up AbstractStorage.RemoveByUserId return parameters for the expectation previously defined by the When method
func (e *AbstractStorageMockRemoveByUserIdExpectation) Then(err error) *AbstractStorageMock {
	e.results = &AbstractStorageMockRemoveByUserIdResults{err}
	return e.mock
}

// Times sets number of times AbstractStorage.RemoveByUserId should be invoked
func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) Times(n uint64) *mAbstractStorageMockRemoveByUserId {
	if n == 0 {
		mmRemoveByUserId.mock.t.Fatalf("Times of AbstractStorageMock.RemoveByUserId mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveByUserId.expectedInvocations, n)
	mmRemoveByUserId.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveByUserId
}

func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) invocationsDone() bool {
	if len(mmRemoveByUserId.expectations) == 0 && mmRemoveByUserId.defaultExpectation == nil && mmRemoveByUserId.mock.funcRemoveByUserId == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveByUserId.mock.afterRemoveByUserIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveByUserId.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveByUserId implements AbstractStorage
func (mmRemoveByUserId *AbstractStorageMock) RemoveByUserId(id model.UserId) (err error) {
	mm_atomic.AddUint64(&mmRemoveByUserId.beforeRemoveByUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveByUserId.afterRemoveByUserIdCounter, 1)

	mmRemoveByUserId.t.Helper()

	if mmRemoveByUserId.inspectFuncRemoveByUserId != nil {
		mmRemoveByUserId.inspectFuncRemoveByUserId(id)
	}

	mm_params := AbstractStorageMockRemoveByUserIdParams{id}

	// Record call args
	mmRemoveByUserId.RemoveByUserIdMock.mutex.Lock()
	mmRemoveByUserId.RemoveByUserIdMock.callArgs = append(mmRemoveByUserId.RemoveByUserIdMock.callArgs, &mm_params)
	mmRemoveByUserId.RemoveByUserIdMock.mutex.Unlock()

	for _, e := range mmRemoveByUserId.RemoveByUserIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.paramPtrs

		mm_got := AbstractStorageMockRemoveByUserIdParams{id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmRemoveByUserId.t.Errorf("AbstractStorageMock.RemoveByUserId got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveByUserId.t.Errorf("AbstractStorageMock.RemoveByUserId got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveByUserId.t.Fatal("No results are set for the AbstractStorageMock.RemoveByUserId")
		}
		return (*mm_results).err
	}
	if mmRemoveByUserId.funcRemoveByUserId != nil {
		return mmRemoveByUserId.funcRemoveByUserId(id)
	}
	mmRemoveByUserId.t.Fatalf("Unexpected call to AbstractStorageMock.RemoveByUserId. %v", id)
	return
}

// RemoveByUserIdAfterCounter returns a count of finished AbstractStorageMock.RemoveByUserId invocations
func (mmRemoveByUserId *AbstractStorageMock) RemoveByUserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveByUserId.afterRemoveByUserIdCounter)
}

// RemoveByUserIdBeforeCounter returns a count of AbstractStorageMock.RemoveByUserId invocations
func (mmRemoveByUserId *AbstractStorageMock) RemoveByUserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveByUserId.beforeRemoveByUserIdCounter)
}

// Calls returns a list of arguments used in each call to AbstractStorageMock.RemoveByUserId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveByUserId *mAbstractStorageMockRemoveByUserId) Calls() []*AbstractStorageMockRemoveByUserIdParams {
	mmRemoveByUserId.mutex.RLock()

	argCopy := make([]*AbstractStorageMockRemoveByUserIdParams, len(mmRemoveByUserId.callArgs))
	copy(argCopy, mmRemoveByUserId.callArgs)

	mmRemoveByUserId.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveByUserIdDone returns true if the count of the RemoveByUserId invocations corresponds
// the number of defined expectations
func (m *AbstractStorageMock) MinimockRemoveByUserIdDone() bool {
	if m.RemoveByUserIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveByUserIdMock.invocationsDone()
}

// MinimockRemoveByUserIdInspect logs each unmet expectation
func (m *AbstractStorageMock) MinimockRemoveByUserIdInspect() {
	for _, e := range m.RemoveByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AbstractStorageMock.RemoveByUserId at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveByUserIdCounter := mm_atomic.LoadUint64(&m.afterRemoveByUserIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveByUserIdMock.defaultExpectation != nil && afterRemoveByUserIdCounter < 1 {
		if m.RemoveByUserIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AbstractStorageMock.RemoveByUserId at\n%s", m.RemoveByUserIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AbstractStorageMock.RemoveByUserId at\n%s with params: %#v", m.RemoveByUserIdMock.defaultExpectation.expectationOrigins.origin, *m.RemoveByUserIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveByUserId != nil && afterRemoveByUserIdCounter < 1 {
		m.t.Errorf("Expected call to AbstractStorageMock.RemoveByUserId at\n%s", m.funcRemoveByUserIdOrigin)
	}

	if !m.RemoveByUserIdMock.invocationsDone() && afterRemoveByUserIdCounter > 0 {
		m.t.Errorf("Expected %d calls to AbstractStorageMock.RemoveByUserId at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveByUserIdMock.expectedInvocations), m.RemoveByUserIdMock.expectedInvocationsOrigin, afterRemoveByUserIdCounter)
	}
}

type mAbstractStorageMockRemoveItem struct {
	optional           bool
	mock               *AbstractStorageMock
	defaultExpectation *AbstractStorageMockRemoveItemExpectation
	expectations       []*AbstractStorageMockRemoveItemExpectation

	callArgs []*AbstractStorageMockRemoveItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AbstractStorageMockRemoveItemExpectation specifies expectation struct of the AbstractStorage.RemoveItem
type AbstractStorageMockRemoveItemExpectation struct {
	mock               *AbstractStorageMock
	params             *AbstractStorageMockRemoveItemParams
	paramPtrs          *AbstractStorageMockRemoveItemParamPtrs
	expectationOrigins AbstractStorageMockRemoveItemExpectationOrigins
	results            *AbstractStorageMockRemoveItemResults
	returnOrigin       string
	Counter            uint64
}

// AbstractStorageMockRemoveItemParams contains parameters of the AbstractStorage.RemoveItem
type AbstractStorageMockRemoveItemParams struct {
	id  model.UserId
	sku model.SKU
}

// AbstractStorageMockRemoveItemParamPtrs contains pointers to parameters of the AbstractStorage.RemoveItem
type AbstractStorageMockRemoveItemParamPtrs struct {
	id  *model.UserId
	sku *model.SKU
}

// AbstractStorageMockRemoveItemResults contains results of the AbstractStorage.RemoveItem
type AbstractStorageMockRemoveItemResults struct {
	err error
}

// AbstractStorageMockRemoveItemOrigins contains origins of expectations of the AbstractStorage.RemoveItem
type AbstractStorageMockRemoveItemExpectationOrigins struct {
	origin    string
	originId  string
	originSku string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveItem *mAbstractStorageMockRemoveItem) Optional() *mAbstractStorageMockRemoveItem {
	mmRemoveItem.optional = true
	return mmRemoveItem
}

// Expect sets up expected params for AbstractStorage.RemoveItem
func (mmRemoveItem *mAbstractStorageMockRemoveItem) Expect(id model.UserId, sku model.SKU) *mAbstractStorageMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("AbstractStorageMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &AbstractStorageMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.paramPtrs != nil {
		mmRemoveItem.mock.t.Fatalf("AbstractStorageMock.RemoveItem mock is already set by ExpectParams functions")
	}

	mmRemoveItem.defaultExpectation.params = &AbstractStorageMockRemoveItemParams{id, sku}
	mmRemoveItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveItem.expectations {
		if minimock.Equal(e.params, mmRemoveItem.defaultExpectation.params) {
			mmRemoveItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveItem.defaultExpectation.params)
		}
	}

	return mmRemoveItem
}

// ExpectIdParam1 sets up expected param id for AbstractStorage.RemoveItem
func (mmRemoveItem *mAbstractStorageMockRemoveItem) ExpectIdParam1(id model.UserId) *mAbstractStorageMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("AbstractStorageMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &AbstractStorageMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("AbstractStorageMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &AbstractStorageMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.id = &id
	mmRemoveItem.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmRemoveItem
}

// ExpectSkuParam2 sets up expected param sku for AbstractStorage.RemoveItem
func (mmRemoveItem *mAbstractStorageMockRemoveItem) ExpectSkuParam2(sku model.SKU) *mAbstractStorageMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("AbstractStorageMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &AbstractStorageMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("AbstractStorageMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &AbstractStorageMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.sku = &sku
	mmRemoveItem.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmRemoveItem
}

// Inspect accepts an inspector function that has same arguments as the AbstractStorage.RemoveItem
func (mmRemoveItem *mAbstractStorageMockRemoveItem) Inspect(f func(id model.UserId, sku model.SKU)) *mAbstractStorageMockRemoveItem {
	if mmRemoveItem.mock.inspectFuncRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("Inspect function is already set for AbstractStorageMock.RemoveItem")
	}

	mmRemoveItem.mock.inspectFuncRemoveItem = f

	return mmRemoveItem
}

// Return sets up results that will be returned by AbstractStorage.RemoveItem
func (mmRemoveItem *mAbstractStorageMockRemoveItem) Return(err error) *AbstractStorageMock {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("AbstractStorageMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &AbstractStorageMockRemoveItemExpectation{mock: mmRemoveItem.mock}
	}
	mmRemoveItem.defaultExpectation.results = &AbstractStorageMockRemoveItemResults{err}
	mmRemoveItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveItem.mock
}

// Set uses given function f to mock the AbstractStorage.RemoveItem method
func (mmRemoveItem *mAbstractStorageMockRemoveItem) Set(f func(id model.UserId, sku model.SKU) (err error)) *AbstractStorageMock {
	if mmRemoveItem.defaultExpectation != nil {
		mmRemoveItem.mock.t.Fatalf("Default expectation is already set for the AbstractStorage.RemoveItem method")
	}

	if len(mmRemoveItem.expectations) > 0 {
		mmRemoveItem.mock.t.Fatalf("Some expectations are already set for the AbstractStorage.RemoveItem method")
	}

	mmRemoveItem.mock.funcRemoveItem = f
	mmRemoveItem.mock.funcRemoveItemOrigin = minimock.CallerInfo(1)
	return mmRemoveItem.mock
}

// When sets expectation for the AbstractStorage.RemoveItem which will trigger the result defined by the following
// Then helper
func (mmRemoveItem *mAbstractStorageMockRemoveItem) When(id model.UserId, sku model.SKU) *AbstractStorageMockRemoveItemExpectation {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("AbstractStorageMock.RemoveItem mock is already set by Set")
	}

	expectation := &AbstractStorageMockRemoveItemExpectation{
		mock:               mmRemoveItem.mock,
		params:             &AbstractStorageMockRemoveItemParams{id, sku},
		expectationOrigins: AbstractStorageMockRemoveItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveItem.expectations = append(mmRemoveItem.expectations, expectation)
	return expectation
}

// Then sets up AbstractStorage.RemoveItem return parameters for the expectation previously defined by the When method
func (e *AbstractStorageMockRemoveItemExpectation) Then(err error) *AbstractStorageMock {
	e.results = &AbstractStorageMockRemoveItemResults{err}
	return e.mock
}

// Times sets number of times AbstractStorage.RemoveItem should be invoked
func (mmRemoveItem *mAbstractStorageMockRemoveItem) Times(n uint64) *mAbstractStorageMockRemoveItem {
	if n == 0 {
		mmRemoveItem.mock.t.Fatalf("Times of AbstractStorageMock.RemoveItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveItem.expectedInvocations, n)
	mmRemoveItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveItem
}

func (mmRemoveItem *mAbstractStorageMockRemoveItem) invocationsDone() bool {
	if len(mmRemoveItem.expectations) == 0 && mmRemoveItem.defaultExpectation == nil && mmRemoveItem.mock.funcRemoveItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveItem.mock.afterRemoveItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveItem implements AbstractStorage
func (mmRemoveItem *AbstractStorageMock) RemoveItem(id model.UserId, sku model.SKU) (err error) {
	mm_atomic.AddUint64(&mmRemoveItem.beforeRemoveItemCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveItem.afterRemoveItemCounter, 1)

	mmRemoveItem.t.Helper()

	if mmRemoveItem.inspectFuncRemoveItem != nil {
		mmRemoveItem.inspectFuncRemoveItem(id, sku)
	}

	mm_params := AbstractStorageMockRemoveItemParams{id, sku}

	// Record call args
	mmRemoveItem.RemoveItemMock.mutex.Lock()
	mmRemoveItem.RemoveItemMock.callArgs = append(mmRemoveItem.RemoveItemMock.callArgs, &mm_params)
	mmRemoveItem.RemoveItemMock.mutex.Unlock()

	for _, e := range mmRemoveItem.RemoveItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveItem.RemoveItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveItem.RemoveItemMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveItem.RemoveItemMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveItem.RemoveItemMock.defaultExpectation.paramPtrs

		mm_got := AbstractStorageMockRemoveItemParams{id, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmRemoveItem.t.Errorf("AbstractStorageMock.RemoveItem got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmRemoveItem.t.Errorf("AbstractStorageMock.RemoveItem got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveItem.t.Errorf("AbstractStorageMock.RemoveItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveItem.RemoveItemMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveItem.t.Fatal("No results are set for the AbstractStorageMock.RemoveItem")
		}
		return (*mm_results).err
	}
	if mmRemoveItem.funcRemoveItem != nil {
		return mmRemoveItem.funcRemoveItem(id, sku)
	}
	mmRemoveItem.t.Fatalf("Unexpected call to AbstractStorageMock.RemoveItem. %v %v", id, sku)
	return
}

// RemoveItemAfterCounter returns a count of finished AbstractStorageMock.RemoveItem invocations
func (mmRemoveItem *AbstractStorageMock) RemoveItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItem.afterRemoveItemCounter)
}

// RemoveItemBeforeCounter returns a count of AbstractStorageMock.RemoveItem invocations
func (mmRemoveItem *AbstractStorageMock) RemoveItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItem.beforeRemoveItemCounter)
}

// Calls returns a list of arguments used in each call to AbstractStorageMock.RemoveItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveItem *mAbstractStorageMockRemoveItem) Calls() []*AbstractStorageMockRemoveItemParams {
	mmRemoveItem.mutex.RLock()

	argCopy := make([]*AbstractStorageMockRemoveItemParams, len(mmRemoveItem.callArgs))
	copy(argCopy, mmRemoveItem.callArgs)

	mmRemoveItem.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveItemDone returns true if the count of the RemoveItem invocations corresponds
// the number of defined expectations
func (m *AbstractStorageMock) MinimockRemoveItemDone() bool {
	if m.RemoveItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveItemMock.invocationsDone()
}

// MinimockRemoveItemInspect logs each unmet expectation
func (m *AbstractStorageMock) MinimockRemoveItemInspect() {
	for _, e := range m.RemoveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AbstractStorageMock.RemoveItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveItemCounter := mm_atomic.LoadUint64(&m.afterRemoveItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveItemMock.defaultExpectation != nil && afterRemoveItemCounter < 1 {
		if m.RemoveItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AbstractStorageMock.RemoveItem at\n%s", m.RemoveItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AbstractStorageMock.RemoveItem at\n%s with params: %#v", m.RemoveItemMock.defaultExpectation.expectationOrigins.origin, *m.RemoveItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveItem != nil && afterRemoveItemCounter < 1 {
		m.t.Errorf("Expected call to AbstractStorageMock.RemoveItem at\n%s", m.funcRemoveItemOrigin)
	}

	if !m.RemoveItemMock.invocationsDone() && afterRemoveItemCounter > 0 {
		m.t.Errorf("Expected %d calls to AbstractStorageMock.RemoveItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveItemMock.expectedInvocations), m.RemoveItemMock.expectedInvocationsOrigin, afterRemoveItemCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AbstractStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockGetCartInspect()

			m.MinimockRemoveByUserIdInspect()

			m.MinimockRemoveItemInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AbstractStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AbstractStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockGetCartDone() &&
		m.MinimockRemoveByUserIdDone() &&
		m.MinimockRemoveItemDone()
}
