// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package cartservice

//go:generate minimock -i route256/cart/internal/pkg/service/cartservice.CartRepository -o cart_repository_mock_test.go -n CartRepositoryMock -p cartservice

import (
	"context"
	"route256/cart/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetCartByUserId          func(ctx context.Context, userId model.UserId) (m1 map[model.SKU]model.CartItem, err error)
	funcGetCartByUserIdOrigin    string
	inspectFuncGetCartByUserId   func(ctx context.Context, userId model.UserId)
	afterGetCartByUserIdCounter  uint64
	beforeGetCartByUserIdCounter uint64
	GetCartByUserIdMock          mCartRepositoryMockGetCartByUserId

	funcInsertItem          func(ctx context.Context, c2 model.CartItem) (cp1 *model.CartItem, err error)
	funcInsertItemOrigin    string
	inspectFuncInsertItem   func(ctx context.Context, c2 model.CartItem)
	afterInsertItemCounter  uint64
	beforeInsertItemCounter uint64
	InsertItemMock          mCartRepositoryMockInsertItem

	funcRemoveByUserId          func(ctx context.Context, userId model.UserId) (err error)
	funcRemoveByUserIdOrigin    string
	inspectFuncRemoveByUserId   func(ctx context.Context, userId model.UserId)
	afterRemoveByUserIdCounter  uint64
	beforeRemoveByUserIdCounter uint64
	RemoveByUserIdMock          mCartRepositoryMockRemoveByUserId

	funcRemoveItem          func(ctx context.Context, userId model.UserId, sku model.SKU) (err error)
	funcRemoveItemOrigin    string
	inspectFuncRemoveItem   func(ctx context.Context, userId model.UserId, sku model.SKU)
	afterRemoveItemCounter  uint64
	beforeRemoveItemCounter uint64
	RemoveItemMock          mCartRepositoryMockRemoveItem
}

// NewCartRepositoryMock returns a mock for CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetCartByUserIdMock = mCartRepositoryMockGetCartByUserId{mock: m}
	m.GetCartByUserIdMock.callArgs = []*CartRepositoryMockGetCartByUserIdParams{}

	m.InsertItemMock = mCartRepositoryMockInsertItem{mock: m}
	m.InsertItemMock.callArgs = []*CartRepositoryMockInsertItemParams{}

	m.RemoveByUserIdMock = mCartRepositoryMockRemoveByUserId{mock: m}
	m.RemoveByUserIdMock.callArgs = []*CartRepositoryMockRemoveByUserIdParams{}

	m.RemoveItemMock = mCartRepositoryMockRemoveItem{mock: m}
	m.RemoveItemMock.callArgs = []*CartRepositoryMockRemoveItemParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockGetCartByUserId struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetCartByUserIdExpectation
	expectations       []*CartRepositoryMockGetCartByUserIdExpectation

	callArgs []*CartRepositoryMockGetCartByUserIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetCartByUserIdExpectation specifies expectation struct of the CartRepository.GetCartByUserId
type CartRepositoryMockGetCartByUserIdExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetCartByUserIdParams
	paramPtrs          *CartRepositoryMockGetCartByUserIdParamPtrs
	expectationOrigins CartRepositoryMockGetCartByUserIdExpectationOrigins
	results            *CartRepositoryMockGetCartByUserIdResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetCartByUserIdParams contains parameters of the CartRepository.GetCartByUserId
type CartRepositoryMockGetCartByUserIdParams struct {
	ctx    context.Context
	userId model.UserId
}

// CartRepositoryMockGetCartByUserIdParamPtrs contains pointers to parameters of the CartRepository.GetCartByUserId
type CartRepositoryMockGetCartByUserIdParamPtrs struct {
	ctx    *context.Context
	userId *model.UserId
}

// CartRepositoryMockGetCartByUserIdResults contains results of the CartRepository.GetCartByUserId
type CartRepositoryMockGetCartByUserIdResults struct {
	m1  map[model.SKU]model.CartItem
	err error
}

// CartRepositoryMockGetCartByUserIdOrigins contains origins of expectations of the CartRepository.GetCartByUserId
type CartRepositoryMockGetCartByUserIdExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) Optional() *mCartRepositoryMockGetCartByUserId {
	mmGetCartByUserId.optional = true
	return mmGetCartByUserId
}

// Expect sets up expected params for CartRepository.GetCartByUserId
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) Expect(ctx context.Context, userId model.UserId) *mCartRepositoryMockGetCartByUserId {
	if mmGetCartByUserId.mock.funcGetCartByUserId != nil {
		mmGetCartByUserId.mock.t.Fatalf("CartRepositoryMock.GetCartByUserId mock is already set by Set")
	}

	if mmGetCartByUserId.defaultExpectation == nil {
		mmGetCartByUserId.defaultExpectation = &CartRepositoryMockGetCartByUserIdExpectation{}
	}

	if mmGetCartByUserId.defaultExpectation.paramPtrs != nil {
		mmGetCartByUserId.mock.t.Fatalf("CartRepositoryMock.GetCartByUserId mock is already set by ExpectParams functions")
	}

	mmGetCartByUserId.defaultExpectation.params = &CartRepositoryMockGetCartByUserIdParams{ctx, userId}
	mmGetCartByUserId.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCartByUserId.expectations {
		if minimock.Equal(e.params, mmGetCartByUserId.defaultExpectation.params) {
			mmGetCartByUserId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCartByUserId.defaultExpectation.params)
		}
	}

	return mmGetCartByUserId
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetCartByUserId
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetCartByUserId {
	if mmGetCartByUserId.mock.funcGetCartByUserId != nil {
		mmGetCartByUserId.mock.t.Fatalf("CartRepositoryMock.GetCartByUserId mock is already set by Set")
	}

	if mmGetCartByUserId.defaultExpectation == nil {
		mmGetCartByUserId.defaultExpectation = &CartRepositoryMockGetCartByUserIdExpectation{}
	}

	if mmGetCartByUserId.defaultExpectation.params != nil {
		mmGetCartByUserId.mock.t.Fatalf("CartRepositoryMock.GetCartByUserId mock is already set by Expect")
	}

	if mmGetCartByUserId.defaultExpectation.paramPtrs == nil {
		mmGetCartByUserId.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartByUserIdParamPtrs{}
	}
	mmGetCartByUserId.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCartByUserId.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCartByUserId
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.GetCartByUserId
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockGetCartByUserId {
	if mmGetCartByUserId.mock.funcGetCartByUserId != nil {
		mmGetCartByUserId.mock.t.Fatalf("CartRepositoryMock.GetCartByUserId mock is already set by Set")
	}

	if mmGetCartByUserId.defaultExpectation == nil {
		mmGetCartByUserId.defaultExpectation = &CartRepositoryMockGetCartByUserIdExpectation{}
	}

	if mmGetCartByUserId.defaultExpectation.params != nil {
		mmGetCartByUserId.mock.t.Fatalf("CartRepositoryMock.GetCartByUserId mock is already set by Expect")
	}

	if mmGetCartByUserId.defaultExpectation.paramPtrs == nil {
		mmGetCartByUserId.defaultExpectation.paramPtrs = &CartRepositoryMockGetCartByUserIdParamPtrs{}
	}
	mmGetCartByUserId.defaultExpectation.paramPtrs.userId = &userId
	mmGetCartByUserId.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmGetCartByUserId
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetCartByUserId
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) Inspect(f func(ctx context.Context, userId model.UserId)) *mCartRepositoryMockGetCartByUserId {
	if mmGetCartByUserId.mock.inspectFuncGetCartByUserId != nil {
		mmGetCartByUserId.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetCartByUserId")
	}

	mmGetCartByUserId.mock.inspectFuncGetCartByUserId = f

	return mmGetCartByUserId
}

// Return sets up results that will be returned by CartRepository.GetCartByUserId
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) Return(m1 map[model.SKU]model.CartItem, err error) *CartRepositoryMock {
	if mmGetCartByUserId.mock.funcGetCartByUserId != nil {
		mmGetCartByUserId.mock.t.Fatalf("CartRepositoryMock.GetCartByUserId mock is already set by Set")
	}

	if mmGetCartByUserId.defaultExpectation == nil {
		mmGetCartByUserId.defaultExpectation = &CartRepositoryMockGetCartByUserIdExpectation{mock: mmGetCartByUserId.mock}
	}
	mmGetCartByUserId.defaultExpectation.results = &CartRepositoryMockGetCartByUserIdResults{m1, err}
	mmGetCartByUserId.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCartByUserId.mock
}

// Set uses given function f to mock the CartRepository.GetCartByUserId method
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) Set(f func(ctx context.Context, userId model.UserId) (m1 map[model.SKU]model.CartItem, err error)) *CartRepositoryMock {
	if mmGetCartByUserId.defaultExpectation != nil {
		mmGetCartByUserId.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetCartByUserId method")
	}

	if len(mmGetCartByUserId.expectations) > 0 {
		mmGetCartByUserId.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetCartByUserId method")
	}

	mmGetCartByUserId.mock.funcGetCartByUserId = f
	mmGetCartByUserId.mock.funcGetCartByUserIdOrigin = minimock.CallerInfo(1)
	return mmGetCartByUserId.mock
}

// When sets expectation for the CartRepository.GetCartByUserId which will trigger the result defined by the following
// Then helper
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) When(ctx context.Context, userId model.UserId) *CartRepositoryMockGetCartByUserIdExpectation {
	if mmGetCartByUserId.mock.funcGetCartByUserId != nil {
		mmGetCartByUserId.mock.t.Fatalf("CartRepositoryMock.GetCartByUserId mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetCartByUserIdExpectation{
		mock:               mmGetCartByUserId.mock,
		params:             &CartRepositoryMockGetCartByUserIdParams{ctx, userId},
		expectationOrigins: CartRepositoryMockGetCartByUserIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCartByUserId.expectations = append(mmGetCartByUserId.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetCartByUserId return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetCartByUserIdExpectation) Then(m1 map[model.SKU]model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetCartByUserIdResults{m1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetCartByUserId should be invoked
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) Times(n uint64) *mCartRepositoryMockGetCartByUserId {
	if n == 0 {
		mmGetCartByUserId.mock.t.Fatalf("Times of CartRepositoryMock.GetCartByUserId mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCartByUserId.expectedInvocations, n)
	mmGetCartByUserId.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCartByUserId
}

func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) invocationsDone() bool {
	if len(mmGetCartByUserId.expectations) == 0 && mmGetCartByUserId.defaultExpectation == nil && mmGetCartByUserId.mock.funcGetCartByUserId == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCartByUserId.mock.afterGetCartByUserIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCartByUserId.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCartByUserId implements CartRepository
func (mmGetCartByUserId *CartRepositoryMock) GetCartByUserId(ctx context.Context, userId model.UserId) (m1 map[model.SKU]model.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetCartByUserId.beforeGetCartByUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCartByUserId.afterGetCartByUserIdCounter, 1)

	mmGetCartByUserId.t.Helper()

	if mmGetCartByUserId.inspectFuncGetCartByUserId != nil {
		mmGetCartByUserId.inspectFuncGetCartByUserId(ctx, userId)
	}

	mm_params := CartRepositoryMockGetCartByUserIdParams{ctx, userId}

	// Record call args
	mmGetCartByUserId.GetCartByUserIdMock.mutex.Lock()
	mmGetCartByUserId.GetCartByUserIdMock.callArgs = append(mmGetCartByUserId.GetCartByUserIdMock.callArgs, &mm_params)
	mmGetCartByUserId.GetCartByUserIdMock.mutex.Unlock()

	for _, e := range mmGetCartByUserId.GetCartByUserIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetCartByUserId.GetCartByUserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCartByUserId.GetCartByUserIdMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCartByUserId.GetCartByUserIdMock.defaultExpectation.params
		mm_want_ptrs := mmGetCartByUserId.GetCartByUserIdMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetCartByUserIdParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCartByUserId.t.Errorf("CartRepositoryMock.GetCartByUserId got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartByUserId.GetCartByUserIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmGetCartByUserId.t.Errorf("CartRepositoryMock.GetCartByUserId got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCartByUserId.GetCartByUserIdMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCartByUserId.t.Errorf("CartRepositoryMock.GetCartByUserId got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCartByUserId.GetCartByUserIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCartByUserId.GetCartByUserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCartByUserId.t.Fatal("No results are set for the CartRepositoryMock.GetCartByUserId")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetCartByUserId.funcGetCartByUserId != nil {
		return mmGetCartByUserId.funcGetCartByUserId(ctx, userId)
	}
	mmGetCartByUserId.t.Fatalf("Unexpected call to CartRepositoryMock.GetCartByUserId. %v %v", ctx, userId)
	return
}

// GetCartByUserIdAfterCounter returns a count of finished CartRepositoryMock.GetCartByUserId invocations
func (mmGetCartByUserId *CartRepositoryMock) GetCartByUserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserId.afterGetCartByUserIdCounter)
}

// GetCartByUserIdBeforeCounter returns a count of CartRepositoryMock.GetCartByUserId invocations
func (mmGetCartByUserId *CartRepositoryMock) GetCartByUserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCartByUserId.beforeGetCartByUserIdCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetCartByUserId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCartByUserId *mCartRepositoryMockGetCartByUserId) Calls() []*CartRepositoryMockGetCartByUserIdParams {
	mmGetCartByUserId.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetCartByUserIdParams, len(mmGetCartByUserId.callArgs))
	copy(argCopy, mmGetCartByUserId.callArgs)

	mmGetCartByUserId.mutex.RUnlock()

	return argCopy
}

// MinimockGetCartByUserIdDone returns true if the count of the GetCartByUserId invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetCartByUserIdDone() bool {
	if m.GetCartByUserIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCartByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCartByUserIdMock.invocationsDone()
}

// MinimockGetCartByUserIdInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetCartByUserIdInspect() {
	for _, e := range m.GetCartByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCartByUserId at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCartByUserIdCounter := mm_atomic.LoadUint64(&m.afterGetCartByUserIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCartByUserIdMock.defaultExpectation != nil && afterGetCartByUserIdCounter < 1 {
		if m.GetCartByUserIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCartByUserId at\n%s", m.GetCartByUserIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetCartByUserId at\n%s with params: %#v", m.GetCartByUserIdMock.defaultExpectation.expectationOrigins.origin, *m.GetCartByUserIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCartByUserId != nil && afterGetCartByUserIdCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetCartByUserId at\n%s", m.funcGetCartByUserIdOrigin)
	}

	if !m.GetCartByUserIdMock.invocationsDone() && afterGetCartByUserIdCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetCartByUserId at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCartByUserIdMock.expectedInvocations), m.GetCartByUserIdMock.expectedInvocationsOrigin, afterGetCartByUserIdCounter)
	}
}

type mCartRepositoryMockInsertItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockInsertItemExpectation
	expectations       []*CartRepositoryMockInsertItemExpectation

	callArgs []*CartRepositoryMockInsertItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockInsertItemExpectation specifies expectation struct of the CartRepository.InsertItem
type CartRepositoryMockInsertItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockInsertItemParams
	paramPtrs          *CartRepositoryMockInsertItemParamPtrs
	expectationOrigins CartRepositoryMockInsertItemExpectationOrigins
	results            *CartRepositoryMockInsertItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockInsertItemParams contains parameters of the CartRepository.InsertItem
type CartRepositoryMockInsertItemParams struct {
	ctx context.Context
	c2  model.CartItem
}

// CartRepositoryMockInsertItemParamPtrs contains pointers to parameters of the CartRepository.InsertItem
type CartRepositoryMockInsertItemParamPtrs struct {
	ctx *context.Context
	c2  *model.CartItem
}

// CartRepositoryMockInsertItemResults contains results of the CartRepository.InsertItem
type CartRepositoryMockInsertItemResults struct {
	cp1 *model.CartItem
	err error
}

// CartRepositoryMockInsertItemOrigins contains origins of expectations of the CartRepository.InsertItem
type CartRepositoryMockInsertItemExpectationOrigins struct {
	origin    string
	originCtx string
	originC2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertItem *mCartRepositoryMockInsertItem) Optional() *mCartRepositoryMockInsertItem {
	mmInsertItem.optional = true
	return mmInsertItem
}

// Expect sets up expected params for CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) Expect(ctx context.Context, c2 model.CartItem) *mCartRepositoryMockInsertItem {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	if mmInsertItem.defaultExpectation == nil {
		mmInsertItem.defaultExpectation = &CartRepositoryMockInsertItemExpectation{}
	}

	if mmInsertItem.defaultExpectation.paramPtrs != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by ExpectParams functions")
	}

	mmInsertItem.defaultExpectation.params = &CartRepositoryMockInsertItemParams{ctx, c2}
	mmInsertItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertItem.expectations {
		if minimock.Equal(e.params, mmInsertItem.defaultExpectation.params) {
			mmInsertItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertItem.defaultExpectation.params)
		}
	}

	return mmInsertItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockInsertItem {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	if mmInsertItem.defaultExpectation == nil {
		mmInsertItem.defaultExpectation = &CartRepositoryMockInsertItemExpectation{}
	}

	if mmInsertItem.defaultExpectation.params != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Expect")
	}

	if mmInsertItem.defaultExpectation.paramPtrs == nil {
		mmInsertItem.defaultExpectation.paramPtrs = &CartRepositoryMockInsertItemParamPtrs{}
	}
	mmInsertItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertItem
}

// ExpectC2Param2 sets up expected param c2 for CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) ExpectC2Param2(c2 model.CartItem) *mCartRepositoryMockInsertItem {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	if mmInsertItem.defaultExpectation == nil {
		mmInsertItem.defaultExpectation = &CartRepositoryMockInsertItemExpectation{}
	}

	if mmInsertItem.defaultExpectation.params != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Expect")
	}

	if mmInsertItem.defaultExpectation.paramPtrs == nil {
		mmInsertItem.defaultExpectation.paramPtrs = &CartRepositoryMockInsertItemParamPtrs{}
	}
	mmInsertItem.defaultExpectation.paramPtrs.c2 = &c2
	mmInsertItem.defaultExpectation.expectationOrigins.originC2 = minimock.CallerInfo(1)

	return mmInsertItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) Inspect(f func(ctx context.Context, c2 model.CartItem)) *mCartRepositoryMockInsertItem {
	if mmInsertItem.mock.inspectFuncInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.InsertItem")
	}

	mmInsertItem.mock.inspectFuncInsertItem = f

	return mmInsertItem
}

// Return sets up results that will be returned by CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) Return(cp1 *model.CartItem, err error) *CartRepositoryMock {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	if mmInsertItem.defaultExpectation == nil {
		mmInsertItem.defaultExpectation = &CartRepositoryMockInsertItemExpectation{mock: mmInsertItem.mock}
	}
	mmInsertItem.defaultExpectation.results = &CartRepositoryMockInsertItemResults{cp1, err}
	mmInsertItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertItem.mock
}

// Set uses given function f to mock the CartRepository.InsertItem method
func (mmInsertItem *mCartRepositoryMockInsertItem) Set(f func(ctx context.Context, c2 model.CartItem) (cp1 *model.CartItem, err error)) *CartRepositoryMock {
	if mmInsertItem.defaultExpectation != nil {
		mmInsertItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.InsertItem method")
	}

	if len(mmInsertItem.expectations) > 0 {
		mmInsertItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.InsertItem method")
	}

	mmInsertItem.mock.funcInsertItem = f
	mmInsertItem.mock.funcInsertItemOrigin = minimock.CallerInfo(1)
	return mmInsertItem.mock
}

// When sets expectation for the CartRepository.InsertItem which will trigger the result defined by the following
// Then helper
func (mmInsertItem *mCartRepositoryMockInsertItem) When(ctx context.Context, c2 model.CartItem) *CartRepositoryMockInsertItemExpectation {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockInsertItemExpectation{
		mock:               mmInsertItem.mock,
		params:             &CartRepositoryMockInsertItemParams{ctx, c2},
		expectationOrigins: CartRepositoryMockInsertItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertItem.expectations = append(mmInsertItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.InsertItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockInsertItemExpectation) Then(cp1 *model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockInsertItemResults{cp1, err}
	return e.mock
}

// Times sets number of times CartRepository.InsertItem should be invoked
func (mmInsertItem *mCartRepositoryMockInsertItem) Times(n uint64) *mCartRepositoryMockInsertItem {
	if n == 0 {
		mmInsertItem.mock.t.Fatalf("Times of CartRepositoryMock.InsertItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertItem.expectedInvocations, n)
	mmInsertItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertItem
}

func (mmInsertItem *mCartRepositoryMockInsertItem) invocationsDone() bool {
	if len(mmInsertItem.expectations) == 0 && mmInsertItem.defaultExpectation == nil && mmInsertItem.mock.funcInsertItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertItem.mock.afterInsertItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertItem implements CartRepository
func (mmInsertItem *CartRepositoryMock) InsertItem(ctx context.Context, c2 model.CartItem) (cp1 *model.CartItem, err error) {
	mm_atomic.AddUint64(&mmInsertItem.beforeInsertItemCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertItem.afterInsertItemCounter, 1)

	mmInsertItem.t.Helper()

	if mmInsertItem.inspectFuncInsertItem != nil {
		mmInsertItem.inspectFuncInsertItem(ctx, c2)
	}

	mm_params := CartRepositoryMockInsertItemParams{ctx, c2}

	// Record call args
	mmInsertItem.InsertItemMock.mutex.Lock()
	mmInsertItem.InsertItemMock.callArgs = append(mmInsertItem.InsertItemMock.callArgs, &mm_params)
	mmInsertItem.InsertItemMock.mutex.Unlock()

	for _, e := range mmInsertItem.InsertItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmInsertItem.InsertItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertItem.InsertItemMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertItem.InsertItemMock.defaultExpectation.params
		mm_want_ptrs := mmInsertItem.InsertItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockInsertItemParams{ctx, c2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertItem.t.Errorf("CartRepositoryMock.InsertItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertItem.InsertItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.c2 != nil && !minimock.Equal(*mm_want_ptrs.c2, mm_got.c2) {
				mmInsertItem.t.Errorf("CartRepositoryMock.InsertItem got unexpected parameter c2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertItem.InsertItemMock.defaultExpectation.expectationOrigins.originC2, *mm_want_ptrs.c2, mm_got.c2, minimock.Diff(*mm_want_ptrs.c2, mm_got.c2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertItem.t.Errorf("CartRepositoryMock.InsertItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertItem.InsertItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertItem.InsertItemMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertItem.t.Fatal("No results are set for the CartRepositoryMock.InsertItem")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmInsertItem.funcInsertItem != nil {
		return mmInsertItem.funcInsertItem(ctx, c2)
	}
	mmInsertItem.t.Fatalf("Unexpected call to CartRepositoryMock.InsertItem. %v %v", ctx, c2)
	return
}

// InsertItemAfterCounter returns a count of finished CartRepositoryMock.InsertItem invocations
func (mmInsertItem *CartRepositoryMock) InsertItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertItem.afterInsertItemCounter)
}

// InsertItemBeforeCounter returns a count of CartRepositoryMock.InsertItem invocations
func (mmInsertItem *CartRepositoryMock) InsertItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertItem.beforeInsertItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.InsertItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertItem *mCartRepositoryMockInsertItem) Calls() []*CartRepositoryMockInsertItemParams {
	mmInsertItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockInsertItemParams, len(mmInsertItem.callArgs))
	copy(argCopy, mmInsertItem.callArgs)

	mmInsertItem.mutex.RUnlock()

	return argCopy
}

// MinimockInsertItemDone returns true if the count of the InsertItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockInsertItemDone() bool {
	if m.InsertItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertItemMock.invocationsDone()
}

// MinimockInsertItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockInsertItemInspect() {
	for _, e := range m.InsertItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.InsertItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertItemCounter := mm_atomic.LoadUint64(&m.afterInsertItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertItemMock.defaultExpectation != nil && afterInsertItemCounter < 1 {
		if m.InsertItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.InsertItem at\n%s", m.InsertItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.InsertItem at\n%s with params: %#v", m.InsertItemMock.defaultExpectation.expectationOrigins.origin, *m.InsertItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertItem != nil && afterInsertItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.InsertItem at\n%s", m.funcInsertItemOrigin)
	}

	if !m.InsertItemMock.invocationsDone() && afterInsertItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.InsertItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertItemMock.expectedInvocations), m.InsertItemMock.expectedInvocationsOrigin, afterInsertItemCounter)
	}
}

type mCartRepositoryMockRemoveByUserId struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockRemoveByUserIdExpectation
	expectations       []*CartRepositoryMockRemoveByUserIdExpectation

	callArgs []*CartRepositoryMockRemoveByUserIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockRemoveByUserIdExpectation specifies expectation struct of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockRemoveByUserIdParams
	paramPtrs          *CartRepositoryMockRemoveByUserIdParamPtrs
	expectationOrigins CartRepositoryMockRemoveByUserIdExpectationOrigins
	results            *CartRepositoryMockRemoveByUserIdResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockRemoveByUserIdParams contains parameters of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdParams struct {
	ctx    context.Context
	userId model.UserId
}

// CartRepositoryMockRemoveByUserIdParamPtrs contains pointers to parameters of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdParamPtrs struct {
	ctx    *context.Context
	userId *model.UserId
}

// CartRepositoryMockRemoveByUserIdResults contains results of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdResults struct {
	err error
}

// CartRepositoryMockRemoveByUserIdOrigins contains origins of expectations of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Optional() *mCartRepositoryMockRemoveByUserId {
	mmRemoveByUserId.optional = true
	return mmRemoveByUserId
}

// Expect sets up expected params for CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Expect(ctx context.Context, userId model.UserId) *mCartRepositoryMockRemoveByUserId {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &CartRepositoryMockRemoveByUserIdExpectation{}
	}

	if mmRemoveByUserId.defaultExpectation.paramPtrs != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by ExpectParams functions")
	}

	mmRemoveByUserId.defaultExpectation.params = &CartRepositoryMockRemoveByUserIdParams{ctx, userId}
	mmRemoveByUserId.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveByUserId.expectations {
		if minimock.Equal(e.params, mmRemoveByUserId.defaultExpectation.params) {
			mmRemoveByUserId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveByUserId.defaultExpectation.params)
		}
	}

	return mmRemoveByUserId
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockRemoveByUserId {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &CartRepositoryMockRemoveByUserIdExpectation{}
	}

	if mmRemoveByUserId.defaultExpectation.params != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Expect")
	}

	if mmRemoveByUserId.defaultExpectation.paramPtrs == nil {
		mmRemoveByUserId.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveByUserIdParamPtrs{}
	}
	mmRemoveByUserId.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveByUserId.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveByUserId
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockRemoveByUserId {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &CartRepositoryMockRemoveByUserIdExpectation{}
	}

	if mmRemoveByUserId.defaultExpectation.params != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Expect")
	}

	if mmRemoveByUserId.defaultExpectation.paramPtrs == nil {
		mmRemoveByUserId.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveByUserIdParamPtrs{}
	}
	mmRemoveByUserId.defaultExpectation.paramPtrs.userId = &userId
	mmRemoveByUserId.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmRemoveByUserId
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Inspect(f func(ctx context.Context, userId model.UserId)) *mCartRepositoryMockRemoveByUserId {
	if mmRemoveByUserId.mock.inspectFuncRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.RemoveByUserId")
	}

	mmRemoveByUserId.mock.inspectFuncRemoveByUserId = f

	return mmRemoveByUserId
}

// Return sets up results that will be returned by CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Return(err error) *CartRepositoryMock {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &CartRepositoryMockRemoveByUserIdExpectation{mock: mmRemoveByUserId.mock}
	}
	mmRemoveByUserId.defaultExpectation.results = &CartRepositoryMockRemoveByUserIdResults{err}
	mmRemoveByUserId.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveByUserId.mock
}

// Set uses given function f to mock the CartRepository.RemoveByUserId method
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Set(f func(ctx context.Context, userId model.UserId) (err error)) *CartRepositoryMock {
	if mmRemoveByUserId.defaultExpectation != nil {
		mmRemoveByUserId.mock.t.Fatalf("Default expectation is already set for the CartRepository.RemoveByUserId method")
	}

	if len(mmRemoveByUserId.expectations) > 0 {
		mmRemoveByUserId.mock.t.Fatalf("Some expectations are already set for the CartRepository.RemoveByUserId method")
	}

	mmRemoveByUserId.mock.funcRemoveByUserId = f
	mmRemoveByUserId.mock.funcRemoveByUserIdOrigin = minimock.CallerInfo(1)
	return mmRemoveByUserId.mock
}

// When sets expectation for the CartRepository.RemoveByUserId which will trigger the result defined by the following
// Then helper
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) When(ctx context.Context, userId model.UserId) *CartRepositoryMockRemoveByUserIdExpectation {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	expectation := &CartRepositoryMockRemoveByUserIdExpectation{
		mock:               mmRemoveByUserId.mock,
		params:             &CartRepositoryMockRemoveByUserIdParams{ctx, userId},
		expectationOrigins: CartRepositoryMockRemoveByUserIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveByUserId.expectations = append(mmRemoveByUserId.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.RemoveByUserId return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockRemoveByUserIdExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockRemoveByUserIdResults{err}
	return e.mock
}

// Times sets number of times CartRepository.RemoveByUserId should be invoked
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Times(n uint64) *mCartRepositoryMockRemoveByUserId {
	if n == 0 {
		mmRemoveByUserId.mock.t.Fatalf("Times of CartRepositoryMock.RemoveByUserId mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveByUserId.expectedInvocations, n)
	mmRemoveByUserId.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveByUserId
}

func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) invocationsDone() bool {
	if len(mmRemoveByUserId.expectations) == 0 && mmRemoveByUserId.defaultExpectation == nil && mmRemoveByUserId.mock.funcRemoveByUserId == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveByUserId.mock.afterRemoveByUserIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveByUserId.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveByUserId implements CartRepository
func (mmRemoveByUserId *CartRepositoryMock) RemoveByUserId(ctx context.Context, userId model.UserId) (err error) {
	mm_atomic.AddUint64(&mmRemoveByUserId.beforeRemoveByUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveByUserId.afterRemoveByUserIdCounter, 1)

	mmRemoveByUserId.t.Helper()

	if mmRemoveByUserId.inspectFuncRemoveByUserId != nil {
		mmRemoveByUserId.inspectFuncRemoveByUserId(ctx, userId)
	}

	mm_params := CartRepositoryMockRemoveByUserIdParams{ctx, userId}

	// Record call args
	mmRemoveByUserId.RemoveByUserIdMock.mutex.Lock()
	mmRemoveByUserId.RemoveByUserIdMock.callArgs = append(mmRemoveByUserId.RemoveByUserIdMock.callArgs, &mm_params)
	mmRemoveByUserId.RemoveByUserIdMock.mutex.Unlock()

	for _, e := range mmRemoveByUserId.RemoveByUserIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockRemoveByUserIdParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveByUserId.t.Errorf("CartRepositoryMock.RemoveByUserId got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmRemoveByUserId.t.Errorf("CartRepositoryMock.RemoveByUserId got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveByUserId.t.Errorf("CartRepositoryMock.RemoveByUserId got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveByUserId.t.Fatal("No results are set for the CartRepositoryMock.RemoveByUserId")
		}
		return (*mm_results).err
	}
	if mmRemoveByUserId.funcRemoveByUserId != nil {
		return mmRemoveByUserId.funcRemoveByUserId(ctx, userId)
	}
	mmRemoveByUserId.t.Fatalf("Unexpected call to CartRepositoryMock.RemoveByUserId. %v %v", ctx, userId)
	return
}

// RemoveByUserIdAfterCounter returns a count of finished CartRepositoryMock.RemoveByUserId invocations
func (mmRemoveByUserId *CartRepositoryMock) RemoveByUserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveByUserId.afterRemoveByUserIdCounter)
}

// RemoveByUserIdBeforeCounter returns a count of CartRepositoryMock.RemoveByUserId invocations
func (mmRemoveByUserId *CartRepositoryMock) RemoveByUserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveByUserId.beforeRemoveByUserIdCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.RemoveByUserId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Calls() []*CartRepositoryMockRemoveByUserIdParams {
	mmRemoveByUserId.mutex.RLock()

	argCopy := make([]*CartRepositoryMockRemoveByUserIdParams, len(mmRemoveByUserId.callArgs))
	copy(argCopy, mmRemoveByUserId.callArgs)

	mmRemoveByUserId.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveByUserIdDone returns true if the count of the RemoveByUserId invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockRemoveByUserIdDone() bool {
	if m.RemoveByUserIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveByUserIdMock.invocationsDone()
}

// MinimockRemoveByUserIdInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockRemoveByUserIdInspect() {
	for _, e := range m.RemoveByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveByUserId at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveByUserIdCounter := mm_atomic.LoadUint64(&m.afterRemoveByUserIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveByUserIdMock.defaultExpectation != nil && afterRemoveByUserIdCounter < 1 {
		if m.RemoveByUserIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveByUserId at\n%s", m.RemoveByUserIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveByUserId at\n%s with params: %#v", m.RemoveByUserIdMock.defaultExpectation.expectationOrigins.origin, *m.RemoveByUserIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveByUserId != nil && afterRemoveByUserIdCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.RemoveByUserId at\n%s", m.funcRemoveByUserIdOrigin)
	}

	if !m.RemoveByUserIdMock.invocationsDone() && afterRemoveByUserIdCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.RemoveByUserId at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveByUserIdMock.expectedInvocations), m.RemoveByUserIdMock.expectedInvocationsOrigin, afterRemoveByUserIdCounter)
	}
}

type mCartRepositoryMockRemoveItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockRemoveItemExpectation
	expectations       []*CartRepositoryMockRemoveItemExpectation

	callArgs []*CartRepositoryMockRemoveItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockRemoveItemExpectation specifies expectation struct of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockRemoveItemParams
	paramPtrs          *CartRepositoryMockRemoveItemParamPtrs
	expectationOrigins CartRepositoryMockRemoveItemExpectationOrigins
	results            *CartRepositoryMockRemoveItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockRemoveItemParams contains parameters of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemParams struct {
	ctx    context.Context
	userId model.UserId
	sku    model.SKU
}

// CartRepositoryMockRemoveItemParamPtrs contains pointers to parameters of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemParamPtrs struct {
	ctx    *context.Context
	userId *model.UserId
	sku    *model.SKU
}

// CartRepositoryMockRemoveItemResults contains results of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemResults struct {
	err error
}

// CartRepositoryMockRemoveItemOrigins contains origins of expectations of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
	originSku    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Optional() *mCartRepositoryMockRemoveItem {
	mmRemoveItem.optional = true
	return mmRemoveItem
}

// Expect sets up expected params for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Expect(ctx context.Context, userId model.UserId, sku model.SKU) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.paramPtrs != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by ExpectParams functions")
	}

	mmRemoveItem.defaultExpectation.params = &CartRepositoryMockRemoveItemParams{ctx, userId, sku}
	mmRemoveItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveItem.expectations {
		if minimock.Equal(e.params, mmRemoveItem.defaultExpectation.params) {
			mmRemoveItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveItem.defaultExpectation.params)
		}
	}

	return mmRemoveItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveItem
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.userId = &userId
	mmRemoveItem.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmRemoveItem
}

// ExpectSkuParam3 sets up expected param sku for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) ExpectSkuParam3(sku model.SKU) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.sku = &sku
	mmRemoveItem.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmRemoveItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Inspect(f func(ctx context.Context, userId model.UserId, sku model.SKU)) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.inspectFuncRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.RemoveItem")
	}

	mmRemoveItem.mock.inspectFuncRemoveItem = f

	return mmRemoveItem
}

// Return sets up results that will be returned by CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Return(err error) *CartRepositoryMock {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{mock: mmRemoveItem.mock}
	}
	mmRemoveItem.defaultExpectation.results = &CartRepositoryMockRemoveItemResults{err}
	mmRemoveItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveItem.mock
}

// Set uses given function f to mock the CartRepository.RemoveItem method
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Set(f func(ctx context.Context, userId model.UserId, sku model.SKU) (err error)) *CartRepositoryMock {
	if mmRemoveItem.defaultExpectation != nil {
		mmRemoveItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.RemoveItem method")
	}

	if len(mmRemoveItem.expectations) > 0 {
		mmRemoveItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.RemoveItem method")
	}

	mmRemoveItem.mock.funcRemoveItem = f
	mmRemoveItem.mock.funcRemoveItemOrigin = minimock.CallerInfo(1)
	return mmRemoveItem.mock
}

// When sets expectation for the CartRepository.RemoveItem which will trigger the result defined by the following
// Then helper
func (mmRemoveItem *mCartRepositoryMockRemoveItem) When(ctx context.Context, userId model.UserId, sku model.SKU) *CartRepositoryMockRemoveItemExpectation {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockRemoveItemExpectation{
		mock:               mmRemoveItem.mock,
		params:             &CartRepositoryMockRemoveItemParams{ctx, userId, sku},
		expectationOrigins: CartRepositoryMockRemoveItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveItem.expectations = append(mmRemoveItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.RemoveItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockRemoveItemExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockRemoveItemResults{err}
	return e.mock
}

// Times sets number of times CartRepository.RemoveItem should be invoked
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Times(n uint64) *mCartRepositoryMockRemoveItem {
	if n == 0 {
		mmRemoveItem.mock.t.Fatalf("Times of CartRepositoryMock.RemoveItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveItem.expectedInvocations, n)
	mmRemoveItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveItem
}

func (mmRemoveItem *mCartRepositoryMockRemoveItem) invocationsDone() bool {
	if len(mmRemoveItem.expectations) == 0 && mmRemoveItem.defaultExpectation == nil && mmRemoveItem.mock.funcRemoveItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveItem.mock.afterRemoveItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveItem implements CartRepository
func (mmRemoveItem *CartRepositoryMock) RemoveItem(ctx context.Context, userId model.UserId, sku model.SKU) (err error) {
	mm_atomic.AddUint64(&mmRemoveItem.beforeRemoveItemCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveItem.afterRemoveItemCounter, 1)

	mmRemoveItem.t.Helper()

	if mmRemoveItem.inspectFuncRemoveItem != nil {
		mmRemoveItem.inspectFuncRemoveItem(ctx, userId, sku)
	}

	mm_params := CartRepositoryMockRemoveItemParams{ctx, userId, sku}

	// Record call args
	mmRemoveItem.RemoveItemMock.mutex.Lock()
	mmRemoveItem.RemoveItemMock.callArgs = append(mmRemoveItem.RemoveItemMock.callArgs, &mm_params)
	mmRemoveItem.RemoveItemMock.mutex.Unlock()

	for _, e := range mmRemoveItem.RemoveItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveItem.RemoveItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveItem.RemoveItemMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveItem.RemoveItemMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveItem.RemoveItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockRemoveItemParams{ctx, userId, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveItem.RemoveItemMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveItem.t.Fatal("No results are set for the CartRepositoryMock.RemoveItem")
		}
		return (*mm_results).err
	}
	if mmRemoveItem.funcRemoveItem != nil {
		return mmRemoveItem.funcRemoveItem(ctx, userId, sku)
	}
	mmRemoveItem.t.Fatalf("Unexpected call to CartRepositoryMock.RemoveItem. %v %v %v", ctx, userId, sku)
	return
}

// RemoveItemAfterCounter returns a count of finished CartRepositoryMock.RemoveItem invocations
func (mmRemoveItem *CartRepositoryMock) RemoveItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItem.afterRemoveItemCounter)
}

// RemoveItemBeforeCounter returns a count of CartRepositoryMock.RemoveItem invocations
func (mmRemoveItem *CartRepositoryMock) RemoveItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItem.beforeRemoveItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.RemoveItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Calls() []*CartRepositoryMockRemoveItemParams {
	mmRemoveItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockRemoveItemParams, len(mmRemoveItem.callArgs))
	copy(argCopy, mmRemoveItem.callArgs)

	mmRemoveItem.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveItemDone returns true if the count of the RemoveItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockRemoveItemDone() bool {
	if m.RemoveItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveItemMock.invocationsDone()
}

// MinimockRemoveItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockRemoveItemInspect() {
	for _, e := range m.RemoveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveItemCounter := mm_atomic.LoadUint64(&m.afterRemoveItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveItemMock.defaultExpectation != nil && afterRemoveItemCounter < 1 {
		if m.RemoveItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s", m.RemoveItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s with params: %#v", m.RemoveItemMock.defaultExpectation.expectationOrigins.origin, *m.RemoveItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveItem != nil && afterRemoveItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s", m.funcRemoveItemOrigin)
	}

	if !m.RemoveItemMock.invocationsDone() && afterRemoveItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.RemoveItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveItemMock.expectedInvocations), m.RemoveItemMock.expectedInvocationsOrigin, afterRemoveItemCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetCartByUserIdInspect()

			m.MinimockInsertItemInspect()

			m.MinimockRemoveByUserIdInspect()

			m.MinimockRemoveItemInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetCartByUserIdDone() &&
		m.MinimockInsertItemDone() &&
		m.MinimockRemoveByUserIdDone() &&
		m.MinimockRemoveItemDone()
}
