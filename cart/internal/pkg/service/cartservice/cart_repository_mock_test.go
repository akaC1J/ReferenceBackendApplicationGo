// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package cartservice

//go:generate minimock -i route256/cart/internal/pkg/service/cartservice.CartRepository -o cart_repository_mock_test.go -n CartRepositoryMock -p cartservice

import (
	"context"
	"route256/cart/internal/pkg/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetItem          func(ctx context.Context, userId model.UserId) (m1 map[model.SKU]model.CartItem, err error)
	funcGetItemOrigin    string
	inspectFuncGetItem   func(ctx context.Context, userId model.UserId)
	afterGetItemCounter  uint64
	beforeGetItemCounter uint64
	GetItemMock          mCartRepositoryMockGetItem

	funcInsertItem          func(ctx context.Context, c2 model.CartItem) (cp1 *model.CartItem, err error)
	funcInsertItemOrigin    string
	inspectFuncInsertItem   func(ctx context.Context, c2 model.CartItem)
	afterInsertItemCounter  uint64
	beforeInsertItemCounter uint64
	InsertItemMock          mCartRepositoryMockInsertItem

	funcRemoveByUserId          func(ctx context.Context, userId model.UserId) (err error)
	funcRemoveByUserIdOrigin    string
	inspectFuncRemoveByUserId   func(ctx context.Context, userId model.UserId)
	afterRemoveByUserIdCounter  uint64
	beforeRemoveByUserIdCounter uint64
	RemoveByUserIdMock          mCartRepositoryMockRemoveByUserId

	funcRemoveItem          func(ctx context.Context, userId model.UserId, sku model.SKU) (err error)
	funcRemoveItemOrigin    string
	inspectFuncRemoveItem   func(ctx context.Context, userId model.UserId, sku model.SKU)
	afterRemoveItemCounter  uint64
	beforeRemoveItemCounter uint64
	RemoveItemMock          mCartRepositoryMockRemoveItem
}

// NewCartRepositoryMock returns a mock for CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetItemMock = mCartRepositoryMockGetItem{mock: m}
	m.GetItemMock.callArgs = []*CartRepositoryMockGetItemParams{}

	m.InsertItemMock = mCartRepositoryMockInsertItem{mock: m}
	m.InsertItemMock.callArgs = []*CartRepositoryMockInsertItemParams{}

	m.RemoveByUserIdMock = mCartRepositoryMockRemoveByUserId{mock: m}
	m.RemoveByUserIdMock.callArgs = []*CartRepositoryMockRemoveByUserIdParams{}

	m.RemoveItemMock = mCartRepositoryMockRemoveItem{mock: m}
	m.RemoveItemMock.callArgs = []*CartRepositoryMockRemoveItemParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockGetItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetItemExpectation
	expectations       []*CartRepositoryMockGetItemExpectation

	callArgs []*CartRepositoryMockGetItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetItemExpectation specifies expectation struct of the CartRepository.GetItem
type CartRepositoryMockGetItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetItemParams
	paramPtrs          *CartRepositoryMockGetItemParamPtrs
	expectationOrigins CartRepositoryMockGetItemExpectationOrigins
	results            *CartRepositoryMockGetItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetItemParams contains parameters of the CartRepository.GetItem
type CartRepositoryMockGetItemParams struct {
	ctx    context.Context
	userId model.UserId
}

// CartRepositoryMockGetItemParamPtrs contains pointers to parameters of the CartRepository.GetItem
type CartRepositoryMockGetItemParamPtrs struct {
	ctx    *context.Context
	userId *model.UserId
}

// CartRepositoryMockGetItemResults contains results of the CartRepository.GetItem
type CartRepositoryMockGetItemResults struct {
	m1  map[model.SKU]model.CartItem
	err error
}

// CartRepositoryMockGetItemOrigins contains origins of expectations of the CartRepository.GetItem
type CartRepositoryMockGetItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItem *mCartRepositoryMockGetItem) Optional() *mCartRepositoryMockGetItem {
	mmGetItem.optional = true
	return mmGetItem
}

// Expect sets up expected params for CartRepository.GetItem
func (mmGetItem *mCartRepositoryMockGetItem) Expect(ctx context.Context, userId model.UserId) *mCartRepositoryMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &CartRepositoryMockGetItemExpectation{}
	}

	if mmGetItem.defaultExpectation.paramPtrs != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by ExpectParams functions")
	}

	mmGetItem.defaultExpectation.params = &CartRepositoryMockGetItemParams{ctx, userId}
	mmGetItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItem.expectations {
		if minimock.Equal(e.params, mmGetItem.defaultExpectation.params) {
			mmGetItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItem.defaultExpectation.params)
		}
	}

	return mmGetItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.GetItem
func (mmGetItem *mCartRepositoryMockGetItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &CartRepositoryMockGetItemExpectation{}
	}

	if mmGetItem.defaultExpectation.params != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Expect")
	}

	if mmGetItem.defaultExpectation.paramPtrs == nil {
		mmGetItem.defaultExpectation.paramPtrs = &CartRepositoryMockGetItemParamPtrs{}
	}
	mmGetItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetItem
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.GetItem
func (mmGetItem *mCartRepositoryMockGetItem) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockGetItem {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &CartRepositoryMockGetItemExpectation{}
	}

	if mmGetItem.defaultExpectation.params != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Expect")
	}

	if mmGetItem.defaultExpectation.paramPtrs == nil {
		mmGetItem.defaultExpectation.paramPtrs = &CartRepositoryMockGetItemParamPtrs{}
	}
	mmGetItem.defaultExpectation.paramPtrs.userId = &userId
	mmGetItem.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmGetItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetItem
func (mmGetItem *mCartRepositoryMockGetItem) Inspect(f func(ctx context.Context, userId model.UserId)) *mCartRepositoryMockGetItem {
	if mmGetItem.mock.inspectFuncGetItem != nil {
		mmGetItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetItem")
	}

	mmGetItem.mock.inspectFuncGetItem = f

	return mmGetItem
}

// Return sets up results that will be returned by CartRepository.GetItem
func (mmGetItem *mCartRepositoryMockGetItem) Return(m1 map[model.SKU]model.CartItem, err error) *CartRepositoryMock {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Set")
	}

	if mmGetItem.defaultExpectation == nil {
		mmGetItem.defaultExpectation = &CartRepositoryMockGetItemExpectation{mock: mmGetItem.mock}
	}
	mmGetItem.defaultExpectation.results = &CartRepositoryMockGetItemResults{m1, err}
	mmGetItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItem.mock
}

// Set uses given function f to mock the CartRepository.GetItem method
func (mmGetItem *mCartRepositoryMockGetItem) Set(f func(ctx context.Context, userId model.UserId) (m1 map[model.SKU]model.CartItem, err error)) *CartRepositoryMock {
	if mmGetItem.defaultExpectation != nil {
		mmGetItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetItem method")
	}

	if len(mmGetItem.expectations) > 0 {
		mmGetItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetItem method")
	}

	mmGetItem.mock.funcGetItem = f
	mmGetItem.mock.funcGetItemOrigin = minimock.CallerInfo(1)
	return mmGetItem.mock
}

// When sets expectation for the CartRepository.GetItem which will trigger the result defined by the following
// Then helper
func (mmGetItem *mCartRepositoryMockGetItem) When(ctx context.Context, userId model.UserId) *CartRepositoryMockGetItemExpectation {
	if mmGetItem.mock.funcGetItem != nil {
		mmGetItem.mock.t.Fatalf("CartRepositoryMock.GetItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetItemExpectation{
		mock:               mmGetItem.mock,
		params:             &CartRepositoryMockGetItemParams{ctx, userId},
		expectationOrigins: CartRepositoryMockGetItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItem.expectations = append(mmGetItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetItemExpectation) Then(m1 map[model.SKU]model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetItemResults{m1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetItem should be invoked
func (mmGetItem *mCartRepositoryMockGetItem) Times(n uint64) *mCartRepositoryMockGetItem {
	if n == 0 {
		mmGetItem.mock.t.Fatalf("Times of CartRepositoryMock.GetItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItem.expectedInvocations, n)
	mmGetItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItem
}

func (mmGetItem *mCartRepositoryMockGetItem) invocationsDone() bool {
	if len(mmGetItem.expectations) == 0 && mmGetItem.defaultExpectation == nil && mmGetItem.mock.funcGetItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItem.mock.afterGetItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItem implements CartRepository
func (mmGetItem *CartRepositoryMock) GetItem(ctx context.Context, userId model.UserId) (m1 map[model.SKU]model.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetItem.beforeGetItemCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItem.afterGetItemCounter, 1)

	mmGetItem.t.Helper()

	if mmGetItem.inspectFuncGetItem != nil {
		mmGetItem.inspectFuncGetItem(ctx, userId)
	}

	mm_params := CartRepositoryMockGetItemParams{ctx, userId}

	// Record call args
	mmGetItem.GetItemMock.mutex.Lock()
	mmGetItem.GetItemMock.callArgs = append(mmGetItem.GetItemMock.callArgs, &mm_params)
	mmGetItem.GetItemMock.mutex.Unlock()

	for _, e := range mmGetItem.GetItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetItem.GetItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItem.GetItemMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItem.GetItemMock.defaultExpectation.params
		mm_want_ptrs := mmGetItem.GetItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetItemParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetItem.t.Errorf("CartRepositoryMock.GetItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItem.GetItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmGetItem.t.Errorf("CartRepositoryMock.GetItem got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItem.GetItemMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItem.t.Errorf("CartRepositoryMock.GetItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItem.GetItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItem.GetItemMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItem.t.Fatal("No results are set for the CartRepositoryMock.GetItem")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetItem.funcGetItem != nil {
		return mmGetItem.funcGetItem(ctx, userId)
	}
	mmGetItem.t.Fatalf("Unexpected call to CartRepositoryMock.GetItem. %v %v", ctx, userId)
	return
}

// GetItemAfterCounter returns a count of finished CartRepositoryMock.GetItem invocations
func (mmGetItem *CartRepositoryMock) GetItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItem.afterGetItemCounter)
}

// GetItemBeforeCounter returns a count of CartRepositoryMock.GetItem invocations
func (mmGetItem *CartRepositoryMock) GetItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItem.beforeGetItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItem *mCartRepositoryMockGetItem) Calls() []*CartRepositoryMockGetItemParams {
	mmGetItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetItemParams, len(mmGetItem.callArgs))
	copy(argCopy, mmGetItem.callArgs)

	mmGetItem.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemDone returns true if the count of the GetItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetItemDone() bool {
	if m.GetItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemMock.invocationsDone()
}

// MinimockGetItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetItemInspect() {
	for _, e := range m.GetItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemCounter := mm_atomic.LoadUint64(&m.afterGetItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemMock.defaultExpectation != nil && afterGetItemCounter < 1 {
		if m.GetItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItem at\n%s", m.GetItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItem at\n%s with params: %#v", m.GetItemMock.defaultExpectation.expectationOrigins.origin, *m.GetItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItem != nil && afterGetItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetItem at\n%s", m.funcGetItemOrigin)
	}

	if !m.GetItemMock.invocationsDone() && afterGetItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemMock.expectedInvocations), m.GetItemMock.expectedInvocationsOrigin, afterGetItemCounter)
	}
}

type mCartRepositoryMockInsertItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockInsertItemExpectation
	expectations       []*CartRepositoryMockInsertItemExpectation

	callArgs []*CartRepositoryMockInsertItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockInsertItemExpectation specifies expectation struct of the CartRepository.InsertItem
type CartRepositoryMockInsertItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockInsertItemParams
	paramPtrs          *CartRepositoryMockInsertItemParamPtrs
	expectationOrigins CartRepositoryMockInsertItemExpectationOrigins
	results            *CartRepositoryMockInsertItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockInsertItemParams contains parameters of the CartRepository.InsertItem
type CartRepositoryMockInsertItemParams struct {
	ctx context.Context
	c2  model.CartItem
}

// CartRepositoryMockInsertItemParamPtrs contains pointers to parameters of the CartRepository.InsertItem
type CartRepositoryMockInsertItemParamPtrs struct {
	ctx *context.Context
	c2  *model.CartItem
}

// CartRepositoryMockInsertItemResults contains results of the CartRepository.InsertItem
type CartRepositoryMockInsertItemResults struct {
	cp1 *model.CartItem
	err error
}

// CartRepositoryMockInsertItemOrigins contains origins of expectations of the CartRepository.InsertItem
type CartRepositoryMockInsertItemExpectationOrigins struct {
	origin    string
	originCtx string
	originC2  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmInsertItem *mCartRepositoryMockInsertItem) Optional() *mCartRepositoryMockInsertItem {
	mmInsertItem.optional = true
	return mmInsertItem
}

// Expect sets up expected params for CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) Expect(ctx context.Context, c2 model.CartItem) *mCartRepositoryMockInsertItem {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	if mmInsertItem.defaultExpectation == nil {
		mmInsertItem.defaultExpectation = &CartRepositoryMockInsertItemExpectation{}
	}

	if mmInsertItem.defaultExpectation.paramPtrs != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by ExpectParams functions")
	}

	mmInsertItem.defaultExpectation.params = &CartRepositoryMockInsertItemParams{ctx, c2}
	mmInsertItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmInsertItem.expectations {
		if minimock.Equal(e.params, mmInsertItem.defaultExpectation.params) {
			mmInsertItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertItem.defaultExpectation.params)
		}
	}

	return mmInsertItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockInsertItem {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	if mmInsertItem.defaultExpectation == nil {
		mmInsertItem.defaultExpectation = &CartRepositoryMockInsertItemExpectation{}
	}

	if mmInsertItem.defaultExpectation.params != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Expect")
	}

	if mmInsertItem.defaultExpectation.paramPtrs == nil {
		mmInsertItem.defaultExpectation.paramPtrs = &CartRepositoryMockInsertItemParamPtrs{}
	}
	mmInsertItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmInsertItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmInsertItem
}

// ExpectC2Param2 sets up expected param c2 for CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) ExpectC2Param2(c2 model.CartItem) *mCartRepositoryMockInsertItem {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	if mmInsertItem.defaultExpectation == nil {
		mmInsertItem.defaultExpectation = &CartRepositoryMockInsertItemExpectation{}
	}

	if mmInsertItem.defaultExpectation.params != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Expect")
	}

	if mmInsertItem.defaultExpectation.paramPtrs == nil {
		mmInsertItem.defaultExpectation.paramPtrs = &CartRepositoryMockInsertItemParamPtrs{}
	}
	mmInsertItem.defaultExpectation.paramPtrs.c2 = &c2
	mmInsertItem.defaultExpectation.expectationOrigins.originC2 = minimock.CallerInfo(1)

	return mmInsertItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) Inspect(f func(ctx context.Context, c2 model.CartItem)) *mCartRepositoryMockInsertItem {
	if mmInsertItem.mock.inspectFuncInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.InsertItem")
	}

	mmInsertItem.mock.inspectFuncInsertItem = f

	return mmInsertItem
}

// Return sets up results that will be returned by CartRepository.InsertItem
func (mmInsertItem *mCartRepositoryMockInsertItem) Return(cp1 *model.CartItem, err error) *CartRepositoryMock {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	if mmInsertItem.defaultExpectation == nil {
		mmInsertItem.defaultExpectation = &CartRepositoryMockInsertItemExpectation{mock: mmInsertItem.mock}
	}
	mmInsertItem.defaultExpectation.results = &CartRepositoryMockInsertItemResults{cp1, err}
	mmInsertItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmInsertItem.mock
}

// Set uses given function f to mock the CartRepository.InsertItem method
func (mmInsertItem *mCartRepositoryMockInsertItem) Set(f func(ctx context.Context, c2 model.CartItem) (cp1 *model.CartItem, err error)) *CartRepositoryMock {
	if mmInsertItem.defaultExpectation != nil {
		mmInsertItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.InsertItem method")
	}

	if len(mmInsertItem.expectations) > 0 {
		mmInsertItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.InsertItem method")
	}

	mmInsertItem.mock.funcInsertItem = f
	mmInsertItem.mock.funcInsertItemOrigin = minimock.CallerInfo(1)
	return mmInsertItem.mock
}

// When sets expectation for the CartRepository.InsertItem which will trigger the result defined by the following
// Then helper
func (mmInsertItem *mCartRepositoryMockInsertItem) When(ctx context.Context, c2 model.CartItem) *CartRepositoryMockInsertItemExpectation {
	if mmInsertItem.mock.funcInsertItem != nil {
		mmInsertItem.mock.t.Fatalf("CartRepositoryMock.InsertItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockInsertItemExpectation{
		mock:               mmInsertItem.mock,
		params:             &CartRepositoryMockInsertItemParams{ctx, c2},
		expectationOrigins: CartRepositoryMockInsertItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmInsertItem.expectations = append(mmInsertItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.InsertItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockInsertItemExpectation) Then(cp1 *model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockInsertItemResults{cp1, err}
	return e.mock
}

// Times sets number of times CartRepository.InsertItem should be invoked
func (mmInsertItem *mCartRepositoryMockInsertItem) Times(n uint64) *mCartRepositoryMockInsertItem {
	if n == 0 {
		mmInsertItem.mock.t.Fatalf("Times of CartRepositoryMock.InsertItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmInsertItem.expectedInvocations, n)
	mmInsertItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmInsertItem
}

func (mmInsertItem *mCartRepositoryMockInsertItem) invocationsDone() bool {
	if len(mmInsertItem.expectations) == 0 && mmInsertItem.defaultExpectation == nil && mmInsertItem.mock.funcInsertItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmInsertItem.mock.afterInsertItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmInsertItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// InsertItem implements CartRepository
func (mmInsertItem *CartRepositoryMock) InsertItem(ctx context.Context, c2 model.CartItem) (cp1 *model.CartItem, err error) {
	mm_atomic.AddUint64(&mmInsertItem.beforeInsertItemCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertItem.afterInsertItemCounter, 1)

	mmInsertItem.t.Helper()

	if mmInsertItem.inspectFuncInsertItem != nil {
		mmInsertItem.inspectFuncInsertItem(ctx, c2)
	}

	mm_params := CartRepositoryMockInsertItemParams{ctx, c2}

	// Record call args
	mmInsertItem.InsertItemMock.mutex.Lock()
	mmInsertItem.InsertItemMock.callArgs = append(mmInsertItem.InsertItemMock.callArgs, &mm_params)
	mmInsertItem.InsertItemMock.mutex.Unlock()

	for _, e := range mmInsertItem.InsertItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmInsertItem.InsertItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertItem.InsertItemMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertItem.InsertItemMock.defaultExpectation.params
		mm_want_ptrs := mmInsertItem.InsertItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockInsertItemParams{ctx, c2}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmInsertItem.t.Errorf("CartRepositoryMock.InsertItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertItem.InsertItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.c2 != nil && !minimock.Equal(*mm_want_ptrs.c2, mm_got.c2) {
				mmInsertItem.t.Errorf("CartRepositoryMock.InsertItem got unexpected parameter c2, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmInsertItem.InsertItemMock.defaultExpectation.expectationOrigins.originC2, *mm_want_ptrs.c2, mm_got.c2, minimock.Diff(*mm_want_ptrs.c2, mm_got.c2))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertItem.t.Errorf("CartRepositoryMock.InsertItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmInsertItem.InsertItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertItem.InsertItemMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertItem.t.Fatal("No results are set for the CartRepositoryMock.InsertItem")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmInsertItem.funcInsertItem != nil {
		return mmInsertItem.funcInsertItem(ctx, c2)
	}
	mmInsertItem.t.Fatalf("Unexpected call to CartRepositoryMock.InsertItem. %v %v", ctx, c2)
	return
}

// InsertItemAfterCounter returns a count of finished CartRepositoryMock.InsertItem invocations
func (mmInsertItem *CartRepositoryMock) InsertItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertItem.afterInsertItemCounter)
}

// InsertItemBeforeCounter returns a count of CartRepositoryMock.InsertItem invocations
func (mmInsertItem *CartRepositoryMock) InsertItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertItem.beforeInsertItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.InsertItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertItem *mCartRepositoryMockInsertItem) Calls() []*CartRepositoryMockInsertItemParams {
	mmInsertItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockInsertItemParams, len(mmInsertItem.callArgs))
	copy(argCopy, mmInsertItem.callArgs)

	mmInsertItem.mutex.RUnlock()

	return argCopy
}

// MinimockInsertItemDone returns true if the count of the InsertItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockInsertItemDone() bool {
	if m.InsertItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.InsertItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.InsertItemMock.invocationsDone()
}

// MinimockInsertItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockInsertItemInspect() {
	for _, e := range m.InsertItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.InsertItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterInsertItemCounter := mm_atomic.LoadUint64(&m.afterInsertItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.InsertItemMock.defaultExpectation != nil && afterInsertItemCounter < 1 {
		if m.InsertItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.InsertItem at\n%s", m.InsertItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.InsertItem at\n%s with params: %#v", m.InsertItemMock.defaultExpectation.expectationOrigins.origin, *m.InsertItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertItem != nil && afterInsertItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.InsertItem at\n%s", m.funcInsertItemOrigin)
	}

	if !m.InsertItemMock.invocationsDone() && afterInsertItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.InsertItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.InsertItemMock.expectedInvocations), m.InsertItemMock.expectedInvocationsOrigin, afterInsertItemCounter)
	}
}

type mCartRepositoryMockRemoveByUserId struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockRemoveByUserIdExpectation
	expectations       []*CartRepositoryMockRemoveByUserIdExpectation

	callArgs []*CartRepositoryMockRemoveByUserIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockRemoveByUserIdExpectation specifies expectation struct of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockRemoveByUserIdParams
	paramPtrs          *CartRepositoryMockRemoveByUserIdParamPtrs
	expectationOrigins CartRepositoryMockRemoveByUserIdExpectationOrigins
	results            *CartRepositoryMockRemoveByUserIdResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockRemoveByUserIdParams contains parameters of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdParams struct {
	ctx    context.Context
	userId model.UserId
}

// CartRepositoryMockRemoveByUserIdParamPtrs contains pointers to parameters of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdParamPtrs struct {
	ctx    *context.Context
	userId *model.UserId
}

// CartRepositoryMockRemoveByUserIdResults contains results of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdResults struct {
	err error
}

// CartRepositoryMockRemoveByUserIdOrigins contains origins of expectations of the CartRepository.RemoveByUserId
type CartRepositoryMockRemoveByUserIdExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Optional() *mCartRepositoryMockRemoveByUserId {
	mmRemoveByUserId.optional = true
	return mmRemoveByUserId
}

// Expect sets up expected params for CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Expect(ctx context.Context, userId model.UserId) *mCartRepositoryMockRemoveByUserId {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &CartRepositoryMockRemoveByUserIdExpectation{}
	}

	if mmRemoveByUserId.defaultExpectation.paramPtrs != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by ExpectParams functions")
	}

	mmRemoveByUserId.defaultExpectation.params = &CartRepositoryMockRemoveByUserIdParams{ctx, userId}
	mmRemoveByUserId.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveByUserId.expectations {
		if minimock.Equal(e.params, mmRemoveByUserId.defaultExpectation.params) {
			mmRemoveByUserId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveByUserId.defaultExpectation.params)
		}
	}

	return mmRemoveByUserId
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockRemoveByUserId {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &CartRepositoryMockRemoveByUserIdExpectation{}
	}

	if mmRemoveByUserId.defaultExpectation.params != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Expect")
	}

	if mmRemoveByUserId.defaultExpectation.paramPtrs == nil {
		mmRemoveByUserId.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveByUserIdParamPtrs{}
	}
	mmRemoveByUserId.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveByUserId.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveByUserId
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockRemoveByUserId {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &CartRepositoryMockRemoveByUserIdExpectation{}
	}

	if mmRemoveByUserId.defaultExpectation.params != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Expect")
	}

	if mmRemoveByUserId.defaultExpectation.paramPtrs == nil {
		mmRemoveByUserId.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveByUserIdParamPtrs{}
	}
	mmRemoveByUserId.defaultExpectation.paramPtrs.userId = &userId
	mmRemoveByUserId.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmRemoveByUserId
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Inspect(f func(ctx context.Context, userId model.UserId)) *mCartRepositoryMockRemoveByUserId {
	if mmRemoveByUserId.mock.inspectFuncRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.RemoveByUserId")
	}

	mmRemoveByUserId.mock.inspectFuncRemoveByUserId = f

	return mmRemoveByUserId
}

// Return sets up results that will be returned by CartRepository.RemoveByUserId
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Return(err error) *CartRepositoryMock {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	if mmRemoveByUserId.defaultExpectation == nil {
		mmRemoveByUserId.defaultExpectation = &CartRepositoryMockRemoveByUserIdExpectation{mock: mmRemoveByUserId.mock}
	}
	mmRemoveByUserId.defaultExpectation.results = &CartRepositoryMockRemoveByUserIdResults{err}
	mmRemoveByUserId.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveByUserId.mock
}

// Set uses given function f to mock the CartRepository.RemoveByUserId method
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Set(f func(ctx context.Context, userId model.UserId) (err error)) *CartRepositoryMock {
	if mmRemoveByUserId.defaultExpectation != nil {
		mmRemoveByUserId.mock.t.Fatalf("Default expectation is already set for the CartRepository.RemoveByUserId method")
	}

	if len(mmRemoveByUserId.expectations) > 0 {
		mmRemoveByUserId.mock.t.Fatalf("Some expectations are already set for the CartRepository.RemoveByUserId method")
	}

	mmRemoveByUserId.mock.funcRemoveByUserId = f
	mmRemoveByUserId.mock.funcRemoveByUserIdOrigin = minimock.CallerInfo(1)
	return mmRemoveByUserId.mock
}

// When sets expectation for the CartRepository.RemoveByUserId which will trigger the result defined by the following
// Then helper
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) When(ctx context.Context, userId model.UserId) *CartRepositoryMockRemoveByUserIdExpectation {
	if mmRemoveByUserId.mock.funcRemoveByUserId != nil {
		mmRemoveByUserId.mock.t.Fatalf("CartRepositoryMock.RemoveByUserId mock is already set by Set")
	}

	expectation := &CartRepositoryMockRemoveByUserIdExpectation{
		mock:               mmRemoveByUserId.mock,
		params:             &CartRepositoryMockRemoveByUserIdParams{ctx, userId},
		expectationOrigins: CartRepositoryMockRemoveByUserIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveByUserId.expectations = append(mmRemoveByUserId.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.RemoveByUserId return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockRemoveByUserIdExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockRemoveByUserIdResults{err}
	return e.mock
}

// Times sets number of times CartRepository.RemoveByUserId should be invoked
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Times(n uint64) *mCartRepositoryMockRemoveByUserId {
	if n == 0 {
		mmRemoveByUserId.mock.t.Fatalf("Times of CartRepositoryMock.RemoveByUserId mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveByUserId.expectedInvocations, n)
	mmRemoveByUserId.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveByUserId
}

func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) invocationsDone() bool {
	if len(mmRemoveByUserId.expectations) == 0 && mmRemoveByUserId.defaultExpectation == nil && mmRemoveByUserId.mock.funcRemoveByUserId == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveByUserId.mock.afterRemoveByUserIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveByUserId.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveByUserId implements CartRepository
func (mmRemoveByUserId *CartRepositoryMock) RemoveByUserId(ctx context.Context, userId model.UserId) (err error) {
	mm_atomic.AddUint64(&mmRemoveByUserId.beforeRemoveByUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveByUserId.afterRemoveByUserIdCounter, 1)

	mmRemoveByUserId.t.Helper()

	if mmRemoveByUserId.inspectFuncRemoveByUserId != nil {
		mmRemoveByUserId.inspectFuncRemoveByUserId(ctx, userId)
	}

	mm_params := CartRepositoryMockRemoveByUserIdParams{ctx, userId}

	// Record call args
	mmRemoveByUserId.RemoveByUserIdMock.mutex.Lock()
	mmRemoveByUserId.RemoveByUserIdMock.callArgs = append(mmRemoveByUserId.RemoveByUserIdMock.callArgs, &mm_params)
	mmRemoveByUserId.RemoveByUserIdMock.mutex.Unlock()

	for _, e := range mmRemoveByUserId.RemoveByUserIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockRemoveByUserIdParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveByUserId.t.Errorf("CartRepositoryMock.RemoveByUserId got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmRemoveByUserId.t.Errorf("CartRepositoryMock.RemoveByUserId got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveByUserId.t.Errorf("CartRepositoryMock.RemoveByUserId got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveByUserId.RemoveByUserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveByUserId.t.Fatal("No results are set for the CartRepositoryMock.RemoveByUserId")
		}
		return (*mm_results).err
	}
	if mmRemoveByUserId.funcRemoveByUserId != nil {
		return mmRemoveByUserId.funcRemoveByUserId(ctx, userId)
	}
	mmRemoveByUserId.t.Fatalf("Unexpected call to CartRepositoryMock.RemoveByUserId. %v %v", ctx, userId)
	return
}

// RemoveByUserIdAfterCounter returns a count of finished CartRepositoryMock.RemoveByUserId invocations
func (mmRemoveByUserId *CartRepositoryMock) RemoveByUserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveByUserId.afterRemoveByUserIdCounter)
}

// RemoveByUserIdBeforeCounter returns a count of CartRepositoryMock.RemoveByUserId invocations
func (mmRemoveByUserId *CartRepositoryMock) RemoveByUserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveByUserId.beforeRemoveByUserIdCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.RemoveByUserId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveByUserId *mCartRepositoryMockRemoveByUserId) Calls() []*CartRepositoryMockRemoveByUserIdParams {
	mmRemoveByUserId.mutex.RLock()

	argCopy := make([]*CartRepositoryMockRemoveByUserIdParams, len(mmRemoveByUserId.callArgs))
	copy(argCopy, mmRemoveByUserId.callArgs)

	mmRemoveByUserId.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveByUserIdDone returns true if the count of the RemoveByUserId invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockRemoveByUserIdDone() bool {
	if m.RemoveByUserIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveByUserIdMock.invocationsDone()
}

// MinimockRemoveByUserIdInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockRemoveByUserIdInspect() {
	for _, e := range m.RemoveByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveByUserId at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveByUserIdCounter := mm_atomic.LoadUint64(&m.afterRemoveByUserIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveByUserIdMock.defaultExpectation != nil && afterRemoveByUserIdCounter < 1 {
		if m.RemoveByUserIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveByUserId at\n%s", m.RemoveByUserIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveByUserId at\n%s with params: %#v", m.RemoveByUserIdMock.defaultExpectation.expectationOrigins.origin, *m.RemoveByUserIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveByUserId != nil && afterRemoveByUserIdCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.RemoveByUserId at\n%s", m.funcRemoveByUserIdOrigin)
	}

	if !m.RemoveByUserIdMock.invocationsDone() && afterRemoveByUserIdCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.RemoveByUserId at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveByUserIdMock.expectedInvocations), m.RemoveByUserIdMock.expectedInvocationsOrigin, afterRemoveByUserIdCounter)
	}
}

type mCartRepositoryMockRemoveItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockRemoveItemExpectation
	expectations       []*CartRepositoryMockRemoveItemExpectation

	callArgs []*CartRepositoryMockRemoveItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockRemoveItemExpectation specifies expectation struct of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockRemoveItemParams
	paramPtrs          *CartRepositoryMockRemoveItemParamPtrs
	expectationOrigins CartRepositoryMockRemoveItemExpectationOrigins
	results            *CartRepositoryMockRemoveItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockRemoveItemParams contains parameters of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemParams struct {
	ctx    context.Context
	userId model.UserId
	sku    model.SKU
}

// CartRepositoryMockRemoveItemParamPtrs contains pointers to parameters of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemParamPtrs struct {
	ctx    *context.Context
	userId *model.UserId
	sku    *model.SKU
}

// CartRepositoryMockRemoveItemResults contains results of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemResults struct {
	err error
}

// CartRepositoryMockRemoveItemOrigins contains origins of expectations of the CartRepository.RemoveItem
type CartRepositoryMockRemoveItemExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
	originSku    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Optional() *mCartRepositoryMockRemoveItem {
	mmRemoveItem.optional = true
	return mmRemoveItem
}

// Expect sets up expected params for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Expect(ctx context.Context, userId model.UserId, sku model.SKU) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.paramPtrs != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by ExpectParams functions")
	}

	mmRemoveItem.defaultExpectation.params = &CartRepositoryMockRemoveItemParams{ctx, userId, sku}
	mmRemoveItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveItem.expectations {
		if minimock.Equal(e.params, mmRemoveItem.defaultExpectation.params) {
			mmRemoveItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveItem.defaultExpectation.params)
		}
	}

	return mmRemoveItem
}

// ExpectCtxParam1 sets up expected param ctx for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) ExpectCtxParam1(ctx context.Context) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveItem.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveItem
}

// ExpectUserIdParam2 sets up expected param userId for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) ExpectUserIdParam2(userId model.UserId) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.userId = &userId
	mmRemoveItem.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmRemoveItem
}

// ExpectSkuParam3 sets up expected param sku for CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) ExpectSkuParam3(sku model.SKU) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{}
	}

	if mmRemoveItem.defaultExpectation.params != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Expect")
	}

	if mmRemoveItem.defaultExpectation.paramPtrs == nil {
		mmRemoveItem.defaultExpectation.paramPtrs = &CartRepositoryMockRemoveItemParamPtrs{}
	}
	mmRemoveItem.defaultExpectation.paramPtrs.sku = &sku
	mmRemoveItem.defaultExpectation.expectationOrigins.originSku = minimock.CallerInfo(1)

	return mmRemoveItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Inspect(f func(ctx context.Context, userId model.UserId, sku model.SKU)) *mCartRepositoryMockRemoveItem {
	if mmRemoveItem.mock.inspectFuncRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.RemoveItem")
	}

	mmRemoveItem.mock.inspectFuncRemoveItem = f

	return mmRemoveItem
}

// Return sets up results that will be returned by CartRepository.RemoveItem
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Return(err error) *CartRepositoryMock {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	if mmRemoveItem.defaultExpectation == nil {
		mmRemoveItem.defaultExpectation = &CartRepositoryMockRemoveItemExpectation{mock: mmRemoveItem.mock}
	}
	mmRemoveItem.defaultExpectation.results = &CartRepositoryMockRemoveItemResults{err}
	mmRemoveItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveItem.mock
}

// Set uses given function f to mock the CartRepository.RemoveItem method
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Set(f func(ctx context.Context, userId model.UserId, sku model.SKU) (err error)) *CartRepositoryMock {
	if mmRemoveItem.defaultExpectation != nil {
		mmRemoveItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.RemoveItem method")
	}

	if len(mmRemoveItem.expectations) > 0 {
		mmRemoveItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.RemoveItem method")
	}

	mmRemoveItem.mock.funcRemoveItem = f
	mmRemoveItem.mock.funcRemoveItemOrigin = minimock.CallerInfo(1)
	return mmRemoveItem.mock
}

// When sets expectation for the CartRepository.RemoveItem which will trigger the result defined by the following
// Then helper
func (mmRemoveItem *mCartRepositoryMockRemoveItem) When(ctx context.Context, userId model.UserId, sku model.SKU) *CartRepositoryMockRemoveItemExpectation {
	if mmRemoveItem.mock.funcRemoveItem != nil {
		mmRemoveItem.mock.t.Fatalf("CartRepositoryMock.RemoveItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockRemoveItemExpectation{
		mock:               mmRemoveItem.mock,
		params:             &CartRepositoryMockRemoveItemParams{ctx, userId, sku},
		expectationOrigins: CartRepositoryMockRemoveItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveItem.expectations = append(mmRemoveItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.RemoveItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockRemoveItemExpectation) Then(err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockRemoveItemResults{err}
	return e.mock
}

// Times sets number of times CartRepository.RemoveItem should be invoked
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Times(n uint64) *mCartRepositoryMockRemoveItem {
	if n == 0 {
		mmRemoveItem.mock.t.Fatalf("Times of CartRepositoryMock.RemoveItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveItem.expectedInvocations, n)
	mmRemoveItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveItem
}

func (mmRemoveItem *mCartRepositoryMockRemoveItem) invocationsDone() bool {
	if len(mmRemoveItem.expectations) == 0 && mmRemoveItem.defaultExpectation == nil && mmRemoveItem.mock.funcRemoveItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveItem.mock.afterRemoveItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveItem implements CartRepository
func (mmRemoveItem *CartRepositoryMock) RemoveItem(ctx context.Context, userId model.UserId, sku model.SKU) (err error) {
	mm_atomic.AddUint64(&mmRemoveItem.beforeRemoveItemCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveItem.afterRemoveItemCounter, 1)

	mmRemoveItem.t.Helper()

	if mmRemoveItem.inspectFuncRemoveItem != nil {
		mmRemoveItem.inspectFuncRemoveItem(ctx, userId, sku)
	}

	mm_params := CartRepositoryMockRemoveItemParams{ctx, userId, sku}

	// Record call args
	mmRemoveItem.RemoveItemMock.mutex.Lock()
	mmRemoveItem.RemoveItemMock.callArgs = append(mmRemoveItem.RemoveItemMock.callArgs, &mm_params)
	mmRemoveItem.RemoveItemMock.mutex.Unlock()

	for _, e := range mmRemoveItem.RemoveItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveItem.RemoveItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveItem.RemoveItemMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveItem.RemoveItemMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveItem.RemoveItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockRemoveItemParams{ctx, userId, sku}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.sku != nil && !minimock.Equal(*mm_want_ptrs.sku, mm_got.sku) {
				mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameter sku, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.originSku, *mm_want_ptrs.sku, mm_got.sku, minimock.Diff(*mm_want_ptrs.sku, mm_got.sku))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveItem.t.Errorf("CartRepositoryMock.RemoveItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveItem.RemoveItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveItem.RemoveItemMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveItem.t.Fatal("No results are set for the CartRepositoryMock.RemoveItem")
		}
		return (*mm_results).err
	}
	if mmRemoveItem.funcRemoveItem != nil {
		return mmRemoveItem.funcRemoveItem(ctx, userId, sku)
	}
	mmRemoveItem.t.Fatalf("Unexpected call to CartRepositoryMock.RemoveItem. %v %v %v", ctx, userId, sku)
	return
}

// RemoveItemAfterCounter returns a count of finished CartRepositoryMock.RemoveItem invocations
func (mmRemoveItem *CartRepositoryMock) RemoveItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItem.afterRemoveItemCounter)
}

// RemoveItemBeforeCounter returns a count of CartRepositoryMock.RemoveItem invocations
func (mmRemoveItem *CartRepositoryMock) RemoveItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveItem.beforeRemoveItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.RemoveItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveItem *mCartRepositoryMockRemoveItem) Calls() []*CartRepositoryMockRemoveItemParams {
	mmRemoveItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockRemoveItemParams, len(mmRemoveItem.callArgs))
	copy(argCopy, mmRemoveItem.callArgs)

	mmRemoveItem.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveItemDone returns true if the count of the RemoveItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockRemoveItemDone() bool {
	if m.RemoveItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveItemMock.invocationsDone()
}

// MinimockRemoveItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockRemoveItemInspect() {
	for _, e := range m.RemoveItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveItemCounter := mm_atomic.LoadUint64(&m.afterRemoveItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveItemMock.defaultExpectation != nil && afterRemoveItemCounter < 1 {
		if m.RemoveItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s", m.RemoveItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s with params: %#v", m.RemoveItemMock.defaultExpectation.expectationOrigins.origin, *m.RemoveItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveItem != nil && afterRemoveItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.RemoveItem at\n%s", m.funcRemoveItemOrigin)
	}

	if !m.RemoveItemMock.invocationsDone() && afterRemoveItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.RemoveItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveItemMock.expectedInvocations), m.RemoveItemMock.expectedInvocationsOrigin, afterRemoveItemCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetItemInspect()

			m.MinimockInsertItemInspect()

			m.MinimockRemoveByUserIdInspect()

			m.MinimockRemoveItemInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetItemDone() &&
		m.MinimockInsertItemDone() &&
		m.MinimockRemoveByUserIdDone() &&
		m.MinimockRemoveItemDone()
}
